<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulse Network - Mindful Journey</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #f8f8f8;
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(26, 26, 26, 0.6);
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid rgba(26, 26, 26, 0.2);
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background: rgba(26, 26, 26, 0.05);
            border-color: rgba(26, 26, 26, 0.4);
        }
    </style>
</head>
<body>
    <a href="gallery.html" class="back-btn">‚Üê Back</a>
    <div class="instruction">Feel the synchronized heartbeat of connected souls</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let figures = [];
        let connections = [];
        let pulseNodes = [];
        let time = 0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f8f8);

            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.z = 40;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createNetwork();
            animate();
        }

        function createNetwork() {
            const nodePositions = [
                { x: -15, y: 8 },
                { x: 0, y: 12 },
                { x: 15, y: 5 },
                { x: -8, y: -5 },
                { x: 8, y: -8 },
                { x: -20, y: -12 },
                { x: 20, y: -15 },
                { x: 0, y: 0 }
            ];

            // Create figures at nodes
            nodePositions.forEach((pos, index) => {
                const figure = createFigure();
                figure.position.set(pos.x, pos.y, 0);
                figure.userData.nodeIndex = index;
                figure.userData.pulsePhase = Math.random() * Math.PI * 2;
                figure.userData.heartRate = 0.8 + Math.random() * 0.4; // Different heart rates
                scene.add(figure);
                figures.push(figure);

                // Create pulse node (heart visualization)
                const pulseGeometry = new THREE.SphereGeometry(0.8, 8, 8);
                const pulseMaterial = new THREE.MeshBasicMaterial({
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0.3
                });
                const pulseNode = new THREE.Mesh(pulseGeometry, pulseMaterial);
                pulseNode.position.set(pos.x, pos.y + 2, 0.5);
                pulseNode.userData.nodeIndex = index;
                scene.add(pulseNode);
                pulseNodes.push(pulseNode);
            });

            // Create connections between nearby figures
            for (let i = 0; i < figures.length; i++) {
                for (let j = i + 1; j < figures.length; j++) {
                    const distance = figures[i].position.distanceTo(figures[j].position);
                    if (distance < 25) {
                        createConnection(figures[i], figures[j], i, j);
                    }
                }
            }
        }

        function createFigure() {
            const figureGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.9, 3, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            figureGroup.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.6, 8, 8);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 2.2;
            figureGroup.add(head);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2, 6);
            const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArm.position.set(-1.2, 0.5, 0);
            leftArm.rotation.z = 0.4;
            figureGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
            rightArm.position.set(1.2, 0.5, 0);
            rightArm.rotation.z = -0.4;
            figureGroup.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2.5, 6);
            const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            leftLeg.position.set(-0.4, -2.8, 0);
            figureGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            rightLeg.position.set(0.4, -2.8, 0);
            figureGroup.add(rightLeg);

            figureGroup.scale.setScalar(0.4);
            return figureGroup;
        }

        function createConnection(figure1, figure2, index1, index2) {
            const points = [figure1.position.clone(), figure2.position.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const material = new THREE.LineBasicMaterial({
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.2
            });
            
            const line = new THREE.Line(geometry, material);
            line.userData = {
                figure1: figure1,
                figure2: figure2,
                index1: index1,
                index2: index2,
                pulseTravel: 0,
                pulseActive: false,
                basePulse: Math.random() * Math.PI * 2
            };
            
            scene.add(line);
            connections.push(line);

            // Create pulse particles that will travel along connections
            for (let i = 0; i < 3; i++) {
                const pulseGeometry = new THREE.SphereGeometry(0.1, 6, 6);
                const pulseMaterial = new THREE.MeshBasicMaterial({
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0
                });
                const pulse = new THREE.Mesh(pulseGeometry, pulseMaterial);
                pulse.userData = {
                    connectionIndex: connections.length - 1,
                    delay: i * 0.3,
                    active: false
                };
                scene.add(pulse);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Global heartbeat synchronization effect
            const globalPulse = Math.sin(time * 1.2) * 0.5 + 0.5;
            const syncStrength = 0.3; // How much figures sync to global pulse

            // Update figures with heartbeat
            figures.forEach((figure, index) => {
                const individualPulse = Math.sin(time * figure.userData.heartRate + figure.userData.pulsePhase);
                const syncedPulse = individualPulse * (1 - syncStrength) + globalPulse * syncStrength * 2;
                const pulseIntensity = (syncedPulse + 1) / 2;

                // Scale pulsing
                const scale = 0.4 + pulseIntensity * 0.1;
                figure.scale.setScalar(scale);

                // Gentle breathing motion
                figure.children.forEach((part, partIndex) => {
                    if (partIndex === 0) { // Body
                        part.scale.y = 1 + pulseIntensity * 0.2;
                    }
                });

                // Opacity pulsing
                figure.children.forEach(part => {
                    part.material.opacity = 0.6 + pulseIntensity * 0.3;
                });
            });

            // Update pulse nodes (hearts)
            pulseNodes.forEach((node, index) => {
                const figure = figures[index];
                const individualPulse = Math.sin(time * figure.userData.heartRate + figure.userData.pulsePhase);
                const syncedPulse = individualPulse * (1 - syncStrength) + globalPulse * syncStrength * 2;
                const pulseIntensity = (syncedPulse + 1) / 2;

                // Heart pulse effect
                const heartScale = 0.8 + pulseIntensity * 0.6;
                node.scale.setScalar(heartScale);
                node.material.opacity = 0.2 + pulseIntensity * 0.4;

                // Gentle floating motion
                node.position.y = figure.position.y + 2 + Math.sin(time * 0.5 + index) * 0.2;
            });

            // Update connections and pulse travel
            connections.forEach((connection, connIndex) => {
                // Update connection line positions
                const points = [
                    connection.userData.figure1.position.clone(),
                    connection.userData.figure2.position.clone()
                ];
                connection.geometry.setFromPoints(points);

                // Connection opacity based on pulse synchronization
                const figure1Pulse = Math.sin(time * figures[connection.userData.index1].userData.heartRate + figures[connection.userData.index1].userData.pulsePhase);
                const figure2Pulse = Math.sin(time * figures[connection.userData.index2].userData.heartRate + figures[connection.userData.index2].userData.pulsePhase);
                const pulseDiff = Math.abs(figure1Pulse - figure2Pulse);
                const syncLevel = 1 - (pulseDiff / 2);
                connection.material.opacity = 0.1 + syncLevel * 0.3;

                // Trigger pulse waves when figures are in sync
                if (syncLevel > 0.8 && !connection.userData.pulseActive) {
                    connection.userData.pulseActive = true;
                    connection.userData.pulseTravel = 0;
                }

                if (connection.userData.pulseActive) {
                    connection.userData.pulseTravel += 0.02;
                    if (connection.userData.pulseTravel > 1) {
                        connection.userData.pulseActive = false;
                    }
                }
            });

            // Update pulse particles traveling along connections
            scene.children.forEach(child => {
                if (child.userData.connectionIndex !== undefined) {
                    const connection = connections[child.userData.connectionIndex];
                    if (connection && connection.userData.pulseActive) {
                        const progress = Math.max(0, connection.userData.pulseTravel - child.userData.delay);
                        if (progress > 0 && progress < 1) {
                            child.userData.active = true;
                            
                            // Interpolate position along connection
                            const start = connection.userData.figure1.position;
                            const end = connection.userData.figure2.position;
                            child.position.lerpVectors(start, end, progress);
                            child.position.z = 1;

                            // Fade in and out
                            const fadeIn = Math.min(progress * 4, 1);
                            const fadeOut = Math.min((1 - progress) * 4, 1);
                            child.material.opacity = Math.min(fadeIn, fadeOut) * 0.8;
                            
                            // Scale based on position
                            const scale = 0.1 + Math.sin(progress * Math.PI) * 0.1;
                            child.scale.setScalar(scale);
                        } else {
                            child.userData.active = false;
                            child.material.opacity = 0;
                        }
                    }
                }
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>