<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Path - Mindful Journey</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(to bottom, #e8e8e8, #f5f5f5);
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(26, 26, 26, 0.2);
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .back-btn:hover {
            background: rgba(255, 255, 255, 1);
            border-color: rgba(26, 26, 26, 0.4);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">‚Üê Back</a>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let walker;
        let footsteps = [];
        let time = 0;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xf5f5f5, 10, 50);

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(0, 10, 20);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: false 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xf5f5f5, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Create the scene
            createLights();
            createGround();
            createWalker();
            
            // Start animation
            animate();
        }

        function createLights() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            // Directional light for shadows
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            
            // Shadow camera setup
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 60;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            
            scene.add(directionalLight);
        }

        function createGround() {
            const geometry = new THREE.PlaneGeometry(100, 100);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xf0f0f0,
                roughness: 1.0,
                metalness: 0
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createWalker() {
            const group = new THREE.Group();
            
            // Material for all body parts
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.9,
                metalness: 0
            });
            
            // Head - smaller and more proportional
            const headGeometry = new THREE.SphereGeometry(0.12, 8, 6);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 1.65;
            head.castShadow = true;
            head.receiveShadow = true;
            
            // Neck
            const neckGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.12, 6);
            const neck = new THREE.Mesh(neckGeometry, bodyMaterial);
            neck.position.y = 1.48;
            neck.castShadow = true;
            
            // Upper torso (shoulders tapering down)
            const upperTorsoGeometry = new THREE.CylinderGeometry(0.12, 0.18, 0.3, 8);
            const upperTorso = new THREE.Mesh(upperTorsoGeometry, bodyMaterial);
            upperTorso.position.y = 1.25;
            upperTorso.castShadow = true;
            upperTorso.receiveShadow = true;
            
            // Lower torso
            const lowerTorsoGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.25, 8);
            const lowerTorso = new THREE.Mesh(lowerTorsoGeometry, bodyMaterial);
            lowerTorso.position.y = 0.95;
            lowerTorso.castShadow = true;
            
            // Waist/Hips
            const hipsGeometry = new THREE.CylinderGeometry(0.14, 0.12, 0.2, 8);
            const hips = new THREE.Mesh(hipsGeometry, bodyMaterial);
            hips.position.y = 0.7;
            hips.castShadow = true;
            
            // Left upper arm
            const upperArmGeometry = new THREE.CylinderGeometry(0.045, 0.055, 0.3, 6);
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            leftUpperArm.position.set(-0.2, 1.2, 0);
            leftUpperArm.rotation.z = 0.2;
            leftUpperArm.castShadow = true;
            
            // Left lower arm
            const lowerArmGeometry = new THREE.CylinderGeometry(0.035, 0.045, 0.3, 6);
            const leftLowerArm = new THREE.Mesh(lowerArmGeometry, bodyMaterial);
            leftLowerArm.position.set(-0.28, 0.95, 0);
            leftLowerArm.rotation.z = 0.15;
            leftLowerArm.castShadow = true;
            
            // Right upper arm
            const rightUpperArm = new THREE.Mesh(upperArmGeometry, bodyMaterial);
            rightUpperArm.position.set(0.2, 1.2, 0);
            rightUpperArm.rotation.z = -0.2;
            rightUpperArm.castShadow = true;
            
            // Right lower arm
            const rightLowerArm = new THREE.Mesh(lowerArmGeometry, bodyMaterial);
            rightLowerArm.position.set(0.28, 0.95, 0);
            rightLowerArm.rotation.z = -0.15;
            rightLowerArm.castShadow = true;
            
            // Left upper leg
            const upperLegGeometry = new THREE.CylinderGeometry(0.07, 0.09, 0.45, 6);
            const leftUpperLeg = new THREE.Mesh(upperLegGeometry, bodyMaterial);
            leftUpperLeg.position.set(-0.12, 0.35, 0);
            leftUpperLeg.castShadow = true;
            
            // Left lower leg
            const lowerLegGeometry = new THREE.CylinderGeometry(0.045, 0.07, 0.45, 6);
            const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, bodyMaterial);
            leftLowerLeg.position.set(-0.12, -0.05, 0);
            leftLowerLeg.castShadow = true;
            
            // Right upper leg
            const rightUpperLeg = new THREE.Mesh(upperLegGeometry, bodyMaterial);
            rightUpperLeg.position.set(0.12, 0.35, 0);
            rightUpperLeg.castShadow = true;
            
            // Right lower leg
            const rightLowerLeg = new THREE.Mesh(lowerLegGeometry, bodyMaterial);
            rightLowerLeg.position.set(0.12, -0.05, 0);
            rightLowerLeg.castShadow = true;
            
            // Add all parts to group
            group.add(head);
            group.add(neck);
            group.add(upperTorso);
            group.add(lowerTorso);
            group.add(hips);
            group.add(leftUpperArm);
            group.add(leftLowerArm);
            group.add(rightUpperArm);
            group.add(rightLowerArm);
            group.add(leftUpperLeg);
            group.add(leftLowerLeg);
            group.add(rightUpperLeg);
            group.add(rightLowerLeg);
            
            // Store body parts for animation
            group.userData = {
                leftUpperArm,
                leftLowerArm,
                rightUpperArm,
                rightLowerArm,
                leftUpperLeg,
                leftLowerLeg,
                rightUpperLeg,
                rightLowerLeg
            };
            
            // Position the walker
            group.position.set(0, 0.3, 0);
            group.scale.set(1.2, 1.2, 1.2);
            
            walker = group;
            scene.add(walker);
        }

        function createFootstep(x, z) {
            const geometry = new THREE.CircleGeometry(0.15, 8);
            const material = new THREE.MeshBasicMaterial({
                color: 0x404040,
                transparent: true,
                opacity: 0.3
            });
            const footstep = new THREE.Mesh(geometry, material);
            footstep.rotation.x = -Math.PI / 2;
            footstep.position.set(x, 0.01, z);
            footstep.userData = { createdAt: time };
            
            scene.add(footstep);
            footsteps.push(footstep);
            
            // Remove old footsteps
            while (footsteps.length > 20) {
                const old = footsteps.shift();
                scene.remove(old);
                old.geometry.dispose();
                old.material.dispose();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.02;

            if (walker) {
                // Create a simple path
                const pathX = Math.sin(time * 0.3) * 8;
                const pathZ = Math.cos(time * 0.3) * 8 - 5;
                
                // Move walker
                walker.position.x = pathX;
                walker.position.z = pathZ;
                
                // Walking bobbing animation
                walker.position.y = 0.3 + Math.abs(Math.sin(time * 5)) * 0.08;
                
                // Body rotation to face direction
                walker.rotation.y = Math.atan2(
                    Math.cos(time * 0.3) * 8,
                    -Math.sin(time * 0.3) * 8
                );
                
                // Animate limbs for walking
                const walkCycle = time * 5;
                const parts = walker.userData;
                
                if (parts) {
                    // Arm swing
                    parts.leftUpperArm.rotation.x = Math.sin(walkCycle) * 0.3;
                    parts.leftLowerArm.rotation.x = Math.sin(walkCycle - 0.5) * 0.2 + 0.1;
                    parts.rightUpperArm.rotation.x = -Math.sin(walkCycle) * 0.3;
                    parts.rightLowerArm.rotation.x = -Math.sin(walkCycle - 0.5) * 0.2 + 0.1;
                    
                    // Leg movement
                    parts.leftUpperLeg.rotation.x = -Math.sin(walkCycle) * 0.4;
                    parts.leftLowerLeg.rotation.x = Math.max(0, -Math.sin(walkCycle - 0.8) * 0.4);
                    parts.rightUpperLeg.rotation.x = Math.sin(walkCycle) * 0.4;
                    parts.rightLowerLeg.rotation.x = Math.max(0, Math.sin(walkCycle - 0.8) * 0.4);
                }
                
                // Create footsteps periodically
                if (Math.floor(time * 5) % 3 === 0 && Math.random() > 0.5) {
                    const offsetX = Math.sin(walker.rotation.y + Math.PI/2) * 0.15;
                    const offsetZ = Math.cos(walker.rotation.y + Math.PI/2) * 0.15;
                    const side = Math.floor(time * 5) % 6 < 3 ? 1 : -1;
                    createFootstep(
                        walker.position.x + offsetX * side,
                        walker.position.z + offsetZ * side
                    );
                }
            }

            // Fade footsteps
            footsteps.forEach((footstep) => {
                const age = time - footstep.userData.createdAt;
                footstep.material.opacity = Math.max(0, 0.3 - age * 0.03);
            });

            // Camera movement
            camera.position.x = Math.sin(time * 0.1) * 8;
            camera.position.z = 20 + Math.cos(time * 0.1) * 8;
            camera.position.y = 10 + Math.sin(time * 0.15) * 2;
            
            if (walker) {
                camera.lookAt(walker.position);
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize when page loads
        window.addEventListener('load', init);
        
        // Also try to initialize immediately
        if (document.readyState === 'complete') {
            init();
        }
    </script>
</body>
</html>