<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lone Wanderer - Solitary Journey</title>
    <style>
        body {
            margin: 0;
            background: #f8f8f8;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        canvas { display: block; }
        .title {
            position: absolute;
            top: 30px;
            left: 30px;
            color: #666;
            font-size: 24px;
            font-weight: 300;
            z-index: 100;
            opacity: 0;
            animation: fadeIn 3s ease-in-out 1s forwards;
        }
        .subtitle {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: #444;
            font-size: 14px;
            z-index: 100;
            opacity: 0;
            animation: fadeIn 3s ease-in-out 2s forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="title">Lone Wanderer</div>
    <div class="subtitle">One soul in infinite space</div>
    
    <script>
        let scene, camera, renderer;
        let wanderer;
        let path = [];
        let pathLine;
        let time = 0;
        let footsteps = [];
        
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xf8f8f8, 10, 50);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 15);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xf8f8f8);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x808080, 0.6);
            scene.add(ambientLight);
            
            // Main directional light (like moonlight)
            const moonLight = new THREE.DirectionalLight(0xffffff, 0.6);
            moonLight.position.set(-10, 15, -5);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            moonLight.shadow.camera.near = 0.1;
            moonLight.shadow.camera.far = 50;
            moonLight.shadow.camera.left = -20;
            moonLight.shadow.camera.right = 20;
            moonLight.shadow.camera.top = 20;
            moonLight.shadow.camera.bottom = -20;
            scene.add(moonLight);
            
            // Create infinite ground plane
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshLambertMaterial({
                color: 0xe8e8e8,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Create distant mountains silhouettes
            createMountains();
            
            // Create the wanderer
            createWanderer();
            
            // Initialize path tracking
            initializePath();
            
            animate();
        }
        
        function createMountains() {
            for (let i = 0; i < 8; i++) {
                const mountainGeometry = new THREE.ConeGeometry(
                    2 + Math.random() * 3, 
                    4 + Math.random() * 6, 
                    8
                );
                const mountainMaterial = new THREE.MeshLambertMaterial({
                    color: 0xcccccc,
                    transparent: true,
                    opacity: 0.3
                });
                
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                
                const angle = (i / 8) * Math.PI * 2;
                mountain.position.x = Math.cos(angle) * (25 + Math.random() * 10);
                mountain.position.z = Math.sin(angle) * (25 + Math.random() * 10);
                mountain.position.y = mountain.geometry.parameters.height / 2;
                
                scene.add(mountain);
            }
        }
        
        function createWanderer() {
            const group = new THREE.Group();
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x444444,
                transparent: true,
                opacity: 0.9
            });
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.12, 8, 6);
            const head = new THREE.Mesh(headGeometry, material);
            head.position.y = 0.65;
            group.add(head);
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.5, 8);
            const body = new THREE.Mesh(bodyGeometry, material);
            body.position.y = 0.3;
            group.add(body);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.35, 6);
            const leftArm = new THREE.Mesh(armGeometry, material);
            const rightArm = new THREE.Mesh(armGeometry, material);
            leftArm.position.set(-0.15, 0.35, 0);
            rightArm.position.set(0.15, 0.35, 0);
            leftArm.rotation.z = 0.3;
            rightArm.rotation.z = -0.3;
            group.add(leftArm);
            group.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.05, 0.06, 0.4, 6);
            const leftLeg = new THREE.Mesh(legGeometry, material);
            const rightLeg = new THREE.Mesh(legGeometry, material);
            leftLeg.position.set(-0.06, -0.15, 0);
            rightLeg.position.set(0.06, -0.15, 0);
            group.add(leftLeg);
            group.add(rightLeg);
            
            // Cape/cloak
            const capeGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const capeMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x222222,
                transparent: true,
                opacity: 0.6
            });
            const cape = new THREE.Mesh(capeGeometry, capeMaterial);
            cape.position.y = 0.25;
            cape.position.z = -0.05;
            group.add(cape);
            
            wanderer = group;
            wanderer.castShadow = true;
            wanderer.position.y = 0.5;
            scene.add(wanderer);
        }
        
        function initializePath() {
            // Create path geometry for tracking the journey
            const pathGeometry = new THREE.BufferGeometry();
            const pathMaterial = new THREE.LineBasicMaterial({
                color: 0x999999,
                transparent: true,
                opacity: 0.4
            });
            
            pathLine = new THREE.Line(pathGeometry, pathMaterial);
            scene.add(pathLine);
        }
        
        function updatePath() {
            if (path.length > 200) {
                path.shift(); // Remove oldest point
            }
            
            path.push(wanderer.position.clone());
            
            // Update path line
            const positions = new Float32Array(path.length * 3);
            path.forEach((point, index) => {
                positions[index * 3] = point.x;
                positions[index * 3 + 1] = point.y;
                positions[index * 3 + 2] = point.z;
            });
            
            pathLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            pathLine.geometry.setDrawRange(0, path.length);
        }
        
        function createFootstep(position) {
            const footstepGeometry = new THREE.CircleGeometry(0.05, 8);
            const footstepMaterial = new THREE.MeshBasicMaterial({
                color: 0xbbbbbb,
                transparent: true,
                opacity: 0.3
            });
            
            const footstep = new THREE.Mesh(footstepGeometry, footstepMaterial);
            footstep.rotation.x = -Math.PI / 2;
            footstep.position.copy(position);
            footstep.position.y = 0.01;
            
            scene.add(footstep);
            footsteps.push({
                mesh: footstep,
                life: 1.0
            });
            
            // Limit footsteps
            if (footsteps.length > 50) {
                scene.remove(footsteps[0].mesh);
                footsteps.shift();
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.01;
            
            // Wanderer movement in a spiral pattern
            const spiralRadius = 3 + Math.sin(time * 0.1) * 2;
            const spiralSpeed = time * 0.3;
            
            const newX = Math.cos(spiralSpeed) * spiralRadius;
            const newZ = Math.sin(spiralSpeed) * spiralRadius;
            
            wanderer.position.x = newX;
            wanderer.position.z = newZ;
            
            // Walking animation
            const walkCycle = Math.sin(time * 6);
            const armSwing = Math.sin(time * 6) * 0.2;
            
            // Leg movement
            wanderer.children[4].rotation.x = walkCycle * 0.4; // Left leg
            wanderer.children[5].rotation.x = -walkCycle * 0.4; // Right leg
            
            // Arm swing
            wanderer.children[2].rotation.x = -armSwing; // Left arm
            wanderer.children[3].rotation.x = armSwing; // Right arm
            
            // Body bob
            wanderer.position.y = 0.5 + Math.sin(time * 8) * 0.02;
            
            // Cape sway
            wanderer.children[6].rotation.x = Math.sin(time * 4) * 0.1;
            
            // Orient wanderer towards movement direction
            const direction = Math.atan2(
                Math.sin(spiralSpeed + 0.01) * spiralRadius - newZ,
                Math.cos(spiralSpeed + 0.01) * spiralRadius - newX
            );
            wanderer.rotation.y = direction;
            
            // Update path every few frames
            if (Math.floor(time * 60) % 10 === 0) {
                updatePath();
                
                // Create occasional footsteps
                if (Math.random() < 0.3) {
                    createFootstep(wanderer.position);
                }
            }
            
            // Fade footsteps
            footsteps.forEach(footstep => {
                footstep.life -= 0.005;
                footstep.mesh.material.opacity = footstep.life * 0.3;
            });
            
            // Remove faded footsteps
            footsteps.filter(footstep => footstep.life <= 0).forEach(footstep => {
                scene.remove(footstep.mesh);
            });
            footsteps = footsteps.filter(footstep => footstep.life > 0);
            
            // Camera follows at a distance
            camera.position.x = wanderer.position.x + Math.sin(time * 0.1) * 5;
            camera.position.z = wanderer.position.z + Math.cos(time * 0.1) * 5 + 10;
            camera.position.y = 8 + Math.sin(time * 0.05) * 2;
            camera.lookAt(wanderer.position);
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize, false);
        
        init();
    </script>
</body>
</html>