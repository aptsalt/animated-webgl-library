<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life Terrain - Mindful Journey</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(to bottom, #f0f0f0, #fafafa);
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(26, 26, 26, 0.2);
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .back-btn:hover {
            background: rgba(255, 255, 255, 1);
            border-color: rgba(26, 26, 26, 0.4);
        }
        
        .milestone {
            position: absolute;
            color: rgba(26, 26, 26, 0.6);
            font-size: 11px;
            letter-spacing: 1px;
            text-transform: uppercase;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">‚Üê Back</a>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Cache buster - forces reload
        console.log('Version: ' + Date.now());
        let scene, camera, renderer;
        let terrain, paths = [];
        let travelers = [];
        let time = 0;
        let cameraAngle = 0;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xf5f5f5, 20, 100);

            camera = new THREE.PerspectiveCamera(
                60, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(30, 25, 30);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            createLighting();
            createTerrain();
            createLifePaths();
            createTravelers();
            animate();
        }

        function createLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(20, 40, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
        }

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(80, 80, 40, 40);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xe8e8e8,
                roughness: 0.9,
                wireframe: false,
                side: THREE.DoubleSide
            });
            
            // Create terrain elevation
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                
                // Create valleys and peaks
                const distance = Math.sqrt(x * x + y * y);
                const angle = Math.atan2(y, x);
                
                // Main mountain ranges
                let height = Math.sin(distance * 0.15) * 3;
                height += Math.cos(angle * 2) * 2;
                height += Math.sin(x * 0.1) * Math.cos(y * 0.1) * 4;
                
                // Add some noise for natural look
                height += (Math.random() - 0.5) * 0.5;
                
                positions.setZ(i, height);
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);

            // Add contour lines for elevation
            createContourLines(geometry);
        }

        function createContourLines(terrainGeometry) {
            const heights = [-3, -2, -1, 0, 1, 2, 3, 4, 5];
            const gridSize = 41; // 40x40 grid has 41 vertices per side
            
            heights.forEach(height => {
                // Horizontal contour lines
                for (let row = 0; row < gridSize - 1; row++) {
                    const contourPoints = [];
                    for (let col = 0; col < gridSize - 1; col++) {
                        const idx1 = row * gridSize + col;
                        const idx2 = row * gridSize + col + 1;
                        
                        const z1 = terrainGeometry.attributes.position.getZ(idx1);
                        const z2 = terrainGeometry.attributes.position.getZ(idx2);
                        
                        if ((z1 <= height && z2 >= height) || (z1 >= height && z2 <= height)) {
                            const t = (height - z1) / (z2 - z1);
                            const x = terrainGeometry.attributes.position.getX(idx1) + 
                                     (terrainGeometry.attributes.position.getX(idx2) - terrainGeometry.attributes.position.getX(idx1)) * t;
                            const y = terrainGeometry.attributes.position.getY(idx1) + 
                                     (terrainGeometry.attributes.position.getY(idx2) - terrainGeometry.attributes.position.getY(idx1)) * t;
                            contourPoints.push(new THREE.Vector3(x, height, -y));
                        }
                    }
                    
                    if (contourPoints.length > 1) {
                        const contourGeometry = new THREE.BufferGeometry().setFromPoints(contourPoints);
                        const contourMaterial = new THREE.LineBasicMaterial({
                            color: 0x606060,
                            transparent: true,
                            opacity: 0.15
                        });
                        const contourLine = new THREE.Line(contourGeometry, contourMaterial);
                        scene.add(contourLine);
                    }
                }
                
                // Vertical contour lines
                for (let col = 0; col < gridSize - 1; col++) {
                    const contourPoints = [];
                    for (let row = 0; row < gridSize - 1; row++) {
                        const idx1 = row * gridSize + col;
                        const idx2 = (row + 1) * gridSize + col;
                        
                        const z1 = terrainGeometry.attributes.position.getZ(idx1);
                        const z2 = terrainGeometry.attributes.position.getZ(idx2);
                        
                        if ((z1 <= height && z2 >= height) || (z1 >= height && z2 <= height)) {
                            const t = (height - z1) / (z2 - z1);
                            const x = terrainGeometry.attributes.position.getX(idx1) + 
                                     (terrainGeometry.attributes.position.getX(idx2) - terrainGeometry.attributes.position.getX(idx1)) * t;
                            const y = terrainGeometry.attributes.position.getY(idx1) + 
                                     (terrainGeometry.attributes.position.getY(idx2) - terrainGeometry.attributes.position.getY(idx1)) * t;
                            contourPoints.push(new THREE.Vector3(x, height, -y));
                        }
                    }
                    
                    if (contourPoints.length > 1) {
                        const contourGeometry = new THREE.BufferGeometry().setFromPoints(contourPoints);
                        const contourMaterial = new THREE.LineBasicMaterial({
                            color: 0x606060,
                            transparent: true,
                            opacity: 0.15
                        });
                        const contourLine = new THREE.Line(contourGeometry, contourMaterial);
                        scene.add(contourLine);
                    }
                }
            });
        }

        function createLifePaths() {
            // Create multiple diverging and converging paths from all sides
            const pathConfigs = [
                { start: new THREE.Vector3(-30, 0, 30), milestone: "birth", splits: 3 },
                { start: new THREE.Vector3(-25, 0, 25), milestone: "childhood", splits: 2 },
                { start: new THREE.Vector3(-20, 0, 20), milestone: "education", splits: 4 },
                { start: new THREE.Vector3(30, 0, -30), milestone: "growth", splits: 3 },
                { start: new THREE.Vector3(25, 0, -25), milestone: "journey", splits: 2 },
                { start: new THREE.Vector3(-30, 0, -30), milestone: "discovery", splits: 3 },
                { start: new THREE.Vector3(30, 0, 30), milestone: "wisdom", splits: 2 }
            ];

            pathConfigs.forEach(config => {
                createPathFromPoint(config.start, config.splits, 0, config.milestone);
            });
        }

        function createPathFromPoint(startPoint, numSplits, depth, milestone) {
            if (depth > 3) return;
            
            for (let i = 0; i < numSplits; i++) {
                const pathPoints = [];
                const segments = 30;
                
                // Create winding path
                for (let j = 0; j <= segments; j++) {
                    const t = j / segments;
                    const spread = (i - numSplits / 2) * 10;
                    
                    const x = startPoint.x + t * 40 + Math.sin(t * Math.PI * 2) * 5 + spread * t;
                    const z = startPoint.z - t * 40 + Math.cos(t * Math.PI * 3) * 3;
                    
                    // Get terrain height at this position
                    const y = getTerrainHeight(x, z) + 0.5;
                    
                    pathPoints.push(new THREE.Vector3(x, y, z));
                }
                
                // Create path line
                const pathGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
                const pathMaterial = new THREE.LineBasicMaterial({
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0.3 - depth * 0.05,
                    linewidth: 3 - depth
                });
                
                const pathLine = new THREE.Line(pathGeometry, pathMaterial);
                pathLine.userData = {
                    points: pathPoints,
                    milestone: milestone,
                    depth: depth,
                    flowSpeed: 0.5 + Math.random() * 0.5
                };
                
                scene.add(pathLine);
                paths.push(pathLine);
                
                // Add flowing particles along path
                createPathParticles(pathPoints);
                
                // Recursive splits
                if (Math.random() > 0.5 && depth < 2) {
                    const splitPoint = pathPoints[Math.floor(pathPoints.length * 0.6)];
                    createPathFromPoint(splitPoint, 2, depth + 1, "choice");
                }
            }
        }

        function getTerrainHeight(x, z) {
            // Sample terrain height at position
            const distance = Math.sqrt(x * x + z * z);
            const angle = Math.atan2(z, x);
            
            let height = Math.sin(distance * 0.15) * 3;
            height += Math.cos(angle * 2) * 2;
            height += Math.sin(x * 0.1) * Math.cos(z * 0.1) * 4;
            
            return height;
        }

        function createPathParticles(pathPoints) {
            const particleCount = 10;
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.2, 4, 4);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x404040,
                    transparent: true,
                    opacity: 0.4
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.userData = {
                    pathPoints: pathPoints,
                    progress: Math.random(),
                    speed: 0.002 + Math.random() * 0.003
                };
                
                scene.add(particle);
                paths.push({ particle: particle, isParticle: true });
            }
        }

        function createTravelers() {
            // Create small figures traveling the paths
            for (let i = 0; i < 5; i++) {
                const group = new THREE.Group();
                
                // Simple traveler figure (using cylinder for r128 compatibility)
                const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.8, 6);
                const bodyMaterial = new THREE.MeshBasicMaterial({
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0.6
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                const headGeometry = new THREE.SphereGeometry(0.2, 4, 4);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 0.7;
                
                group.add(body);
                group.add(head);
                group.scale.set(1.5, 1.5, 1.5);
                
                // Assign to random path
                const pathIndex = Math.floor(Math.random() * paths.length);
                const path = paths[pathIndex];
                
                if (path && path.userData && path.userData.points) {
                    group.userData = {
                        pathPoints: path.userData.points,
                        progress: Math.random(),
                        speed: 0.001 + Math.random() * 0.002
                    };
                    
                    scene.add(group);
                    travelers.push(group);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.005;

            // Animate path particles
            paths.forEach(item => {
                if (item.isParticle && item.particle) {
                    const particle = item.particle;
                    if (particle.userData.pathPoints) {
                        particle.userData.progress += particle.userData.speed;
                        if (particle.userData.progress > 1) particle.userData.progress = 0;
                        
                        const index = Math.floor(particle.userData.progress * (particle.userData.pathPoints.length - 1));
                        const point = particle.userData.pathPoints[index];
                        
                        if (point) {
                            particle.position.copy(point);
                            particle.position.y += Math.sin(time * 3 + particle.userData.progress * Math.PI * 2) * 0.3;
                            
                            // Pulsing
                            const scale = 1 + Math.sin(time * 2 + particle.userData.progress * Math.PI) * 0.3;
                            particle.scale.set(scale, scale, scale);
                        }
                    }
                } else if (item.userData) {
                    // Subtle path animation
                    item.material.opacity = 0.3 + Math.sin(time + item.userData.depth) * 0.05;
                }
            });

            // Animate travelers
            travelers.forEach(traveler => {
                if (traveler.userData.pathPoints) {
                    traveler.userData.progress += traveler.userData.speed;
                    if (traveler.userData.progress > 1) traveler.userData.progress = 0;
                    
                    const index = Math.floor(traveler.userData.progress * (traveler.userData.pathPoints.length - 1));
                    const point = traveler.userData.pathPoints[index];
                    
                    if (point) {
                        traveler.position.copy(point);
                        traveler.position.y += 0.5;
                        
                        // Walking animation
                        traveler.position.y += Math.abs(Math.sin(time * 10)) * 0.2;
                        traveler.rotation.y = Math.atan2(
                            traveler.userData.pathPoints[Math.min(index + 1, traveler.userData.pathPoints.length - 1)].x - point.x,
                            traveler.userData.pathPoints[Math.min(index + 1, traveler.userData.pathPoints.length - 1)].z - point.z
                        );
                    }
                }
            });

            // Rotate camera around terrain
            cameraAngle += 0.003;
            camera.position.x = Math.cos(cameraAngle) * 40;
            camera.position.z = Math.sin(cameraAngle) * 40;
            camera.position.y = 25 + Math.sin(time * 0.5) * 5;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>