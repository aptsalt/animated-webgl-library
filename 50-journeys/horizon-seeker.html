<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horizon Seeker - Mindful Journey</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #f8f8f8;
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(26, 26, 26, 0.6);
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid rgba(26, 26, 26, 0.2);
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background: rgba(26, 26, 26, 0.05);
            border-color: rgba(26, 26, 26, 0.4);
        }
    </style>
</head>
<body>
    <a href="gallery.html" class="back-btn">‚Üê Back</a>
    <div class="instruction">Walking toward the endless horizon</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let seeker;
        let horizonLine;
        let footsteps = [];
        let time = 0;
        let walkingPhase = 0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f8f8);

            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(0, 3, 8);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createSeeker();
            createHorizon();
            createGround();
            animate();
        }

        function createSeeker() {
            const seekerGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 3.5, 8);
            const seekerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, seekerMaterial);
            seekerGroup.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.7, 8, 8);
            const head = new THREE.Mesh(headGeometry, seekerMaterial);
            head.position.y = 2.6;
            seekerGroup.add(head);
            
            // Arms (swinging)
            const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 6);
            const leftArm = new THREE.Mesh(armGeometry, seekerMaterial);
            leftArm.position.set(-1.3, 1, 0);
            seekerGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, seekerMaterial);
            rightArm.position.set(1.3, 1, 0);
            seekerGroup.add(rightArm);
            
            // Legs (walking)
            const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 3, 6);
            const leftLeg = new THREE.Mesh(legGeometry, seekerMaterial);
            leftLeg.position.set(-0.5, -3.2, 0);
            seekerGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, seekerMaterial);
            rightLeg.position.set(0.5, -3.2, 0);
            seekerGroup.add(rightLeg);

            seekerGroup.position.set(0, 1.8, 0);
            seekerGroup.scale.setScalar(0.6);
            scene.add(seekerGroup);
            seeker = seekerGroup;
        }

        function createHorizon() {
            // Horizon line
            const horizonGeometry = new THREE.PlaneGeometry(200, 1);
            const horizonMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.3
            });
            horizonLine = new THREE.Mesh(horizonGeometry, horizonMaterial);
            horizonLine.position.set(0, 2, -80);
            scene.add(horizonLine);
            
            // Distant elements on horizon
            for (let i = 0; i < 8; i++) {
                const elementGeometry = new THREE.CylinderGeometry(
                    0.1, 0.1, 1 + Math.random() * 2, 6
                );
                const element = new THREE.Mesh(elementGeometry, horizonMaterial);
                element.position.set(
                    (Math.random() - 0.5) * 100,
                    1 + Math.random(),
                    -70 - Math.random() * 20
                );
                element.material.opacity = 0.1 + Math.random() * 0.1;
                scene.add(element);
            }
        }

        function createGround() {
            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(100, 200);
            const groundMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = -50;
            scene.add(ground);
        }

        function createFootstep() {
            const footstepGeometry = new THREE.CircleGeometry(0.2, 8);
            const footstepMaterial = new THREE.MeshBasicMaterial({
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.3
            });
            const footstep = new THREE.Mesh(footstepGeometry, footstepMaterial);
            footstep.rotation.x = -Math.PI / 2;
            footstep.position.copy(seeker.position);
            footstep.position.y = 0.01;
            footstep.position.x += (Math.random() - 0.5) * 0.5;
            footstep.userData.life = 1.0;
            scene.add(footstep);
            footsteps.push(footstep);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            walkingPhase += 0.1;

            if (seeker) {
                // Walking animation
                const walkCycle = Math.sin(walkingPhase);
                const walkCycle2 = Math.sin(walkingPhase + Math.PI);
                
                // Body bobbing
                seeker.position.y = 1.8 + Math.abs(walkCycle) * 0.1;
                
                // Body lean forward slightly
                seeker.rotation.x = 0.05;
                seeker.rotation.z = walkCycle * 0.02;
                
                // Leg movement
                seeker.children[4].rotation.x = walkCycle * 0.5; // Left leg
                seeker.children[5].rotation.x = walkCycle2 * 0.5; // Right leg
                
                // Arm swinging (opposite to legs)
                seeker.children[2].rotation.x = walkCycle2 * 0.3; // Left arm
                seeker.children[3].rotation.x = walkCycle * 0.3; // Right arm
                
                // Head looking toward horizon
                seeker.children[1].rotation.x = Math.sin(time * 0.1) * 0.1;
                seeker.children[1].rotation.y = Math.sin(time * 0.05) * 0.05;
                
                // Create footsteps
                if (Math.abs(walkCycle) > 0.8 && Math.random() < 0.3) {
                    createFootstep();
                }
                
                // Breathing while walking
                const breath = Math.sin(time * 1.5) * 0.5 + 0.5;
                seeker.children[0].scale.y = 1 + breath * 0.05;
            }

            // Update footsteps
            footsteps = footsteps.filter(footstep => {
                footstep.userData.life -= 0.005;
                footstep.material.opacity = footstep.userData.life * 0.3;
                
                if (footstep.userData.life <= 0) {
                    scene.remove(footstep);
                    footstep.geometry.dispose();
                    footstep.material.dispose();
                    return false;
                }
                return true;
            });

            // Horizon effects
            if (horizonLine) {
                horizonLine.material.opacity = 0.2 + Math.sin(time * 0.5) * 0.1;
                horizonLine.position.y = 2 + Math.sin(time * 0.2) * 0.2;
            }

            // Camera following seeker with artistic movement
            const cameraDistance = 8 + Math.sin(time * 0.1) * 2;
            const cameraHeight = 3 + Math.sin(time * 0.05) * 1;
            const cameraAngle = Math.sin(time * 0.02) * 0.1;
            
            camera.position.x = Math.sin(cameraAngle) * 2;
            camera.position.y = cameraHeight;
            camera.position.z = cameraDistance;
            camera.lookAt(seeker.position.x, seeker.position.y + 1, seeker.position.z);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>