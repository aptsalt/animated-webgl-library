<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo Chamber - Resonating Presence</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #f8f8f8;
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(26, 26, 26, 0.2);
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .back-btn:hover {
            background: rgba(255, 255, 255, 1);
            border-color: rgba(26, 26, 26, 0.4);
        }
        
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(26, 26, 26, 0.4);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <a href="gallery.html" class="back-btn">‚Üê Back</a>
    <div class="instruction">Click to create echoes</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let centralFigure;
        let echoes = [];
        let ripples = [];
        let time = 0;
        let mouse = new THREE.Vector2();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f8f8);
            scene.fog = new THREE.Fog(0xf0f0f0, 10, 50);

            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(0, 10, 30);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createCentralFigure();
            createCircularChamber();
            animate();
        }

        function createCentralFigure() {
            const group = new THREE.Group();
            
            const material = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.8
            });

            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
            const body = new THREE.Mesh(bodyGeometry, material);
            body.castShadow = true;
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.35, 8, 6);
            const head = new THREE.Mesh(headGeometry, material);
            head.position.y = 1.2;
            head.castShadow = true;
            
            group.add(body);
            group.add(head);
            
            centralFigure = group;
            scene.add(centralFigure);
        }

        function createCircularChamber() {
            // Create circular walls with gaps
            const wallCount = 24;
            for (let i = 0; i < wallCount; i++) {
                const angle = (i / wallCount) * Math.PI * 2;
                const radius = 15;
                
                const wallGeometry = new THREE.BoxGeometry(0.5, 8, 2);
                const wallMaterial = new THREE.MeshStandardMaterial({
                    color: 0xd0d0d0,
                    transparent: true,
                    opacity: 0.3
                });
                
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.x = Math.cos(angle) * radius;
                wall.position.z = Math.sin(angle) * radius;
                wall.position.y = 4;
                wall.rotation.y = angle;
                wall.receiveShadow = true;
                
                scene.add(wall);
            }

            // Floor
            const floorGeometry = new THREE.CircleGeometry(20, 32);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0xe8e8e8,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -1;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        function createEcho(position) {
            const echo = new THREE.Group();
            
            const material = new THREE.MeshStandardMaterial({
                color: 0x606060,
                transparent: true,
                opacity: 0.6
            });

            // Echo body
            const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.25, 1.3, 8);
            const body = new THREE.Mesh(bodyGeometry, material);
            
            // Echo head
            const headGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const head = new THREE.Mesh(headGeometry, material);
            head.position.y = 1.1;
            
            echo.add(body);
            echo.add(head);
            echo.position.copy(position);
            
            echo.userData = {
                age: 0,
                maxAge: 200,
                speed: 0.1 + Math.random() * 0.1,
                direction: Math.random() * Math.PI * 2,
                fadeSpeed: 0.005
            };
            
            scene.add(echo);
            echoes.push(echo);
        }

        function createRipple(position) {
            const geometry = new THREE.RingGeometry(0.1, 0.5, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0x808080,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            
            const ripple = new THREE.Mesh(geometry, material);
            ripple.position.copy(position);
            ripple.position.y = 0.01;
            ripple.rotation.x = -Math.PI / 2;
            
            ripple.userData = {
                age: 0,
                maxAge: 100,
                expandSpeed: 0.2
            };
            
            scene.add(ripple);
            ripples.push(ripple);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Animate central figure
            if (centralFigure) {
                centralFigure.rotation.y = Math.sin(time * 0.5) * 0.2;
                centralFigure.position.y = Math.sin(time) * 0.2;
                
                // Breathing effect
                const breathScale = 1 + Math.sin(time * 2) * 0.05;
                centralFigure.scale.set(breathScale, breathScale, breathScale);
            }

            // Animate echoes
            echoes.forEach((echo, index) => {
                echo.userData.age++;
                
                // Move outward
                const angle = echo.userData.direction;
                echo.position.x += Math.cos(angle) * echo.userData.speed;
                echo.position.z += Math.sin(angle) * echo.userData.speed;
                
                // Fade out
                echo.children.forEach(child => {
                    child.material.opacity = Math.max(0, 0.6 - (echo.userData.age / echo.userData.maxAge));
                });
                
                // Bounce off walls
                const distance = Math.sqrt(echo.position.x ** 2 + echo.position.z ** 2);
                if (distance > 14) {
                    echo.userData.direction += Math.PI;
                }
                
                // Remove old echoes
                if (echo.userData.age > echo.userData.maxAge) {
                    scene.remove(echo);
                    echoes.splice(index, 1);
                }
            });

            // Animate ripples
            ripples.forEach((ripple, index) => {
                ripple.userData.age++;
                
                // Expand
                const scale = 1 + ripple.userData.age * ripple.userData.expandSpeed;
                ripple.scale.set(scale, scale, 1);
                
                // Fade
                ripple.material.opacity = Math.max(0, 0.5 - (ripple.userData.age / ripple.userData.maxAge));
                
                // Remove old ripples
                if (ripple.userData.age > ripple.userData.maxAge) {
                    scene.remove(ripple);
                    ripples.splice(index, 1);
                }
            });

            // Camera movement
            camera.position.x = Math.sin(time * 0.1) * 5;
            camera.position.z = 30 + Math.cos(time * 0.1) * 5;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        // Mouse interaction
        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Create echo at central figure position
            if (centralFigure) {
                createEcho(centralFigure.position.clone());
                createRipple(centralFigure.position.clone());
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>