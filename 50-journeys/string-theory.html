<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Theory - Mindful Journey</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #f8f8f8;
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(26, 26, 26, 0.6);
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid rgba(26, 26, 26, 0.2);
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background: rgba(26, 26, 26, 0.05);
            border-color: rgba(26, 26, 26, 0.4);
        }
    </style>
</head>
<body>
    <a href="gallery.html" class="back-btn">‚Üê Back</a>
    <div class="instruction">Witness quantum connections vibrating between souls</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let figures = [];
        let strings = [];
        let time = 0;
        let mouse = new THREE.Vector2();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f8f8);

            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.z = 45;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createQuantumNetwork();
            animate();
        }

        function createQuantumNetwork() {
            // Create figures at strategic positions
            const positions = [
                { x: -18, y: 8 },
                { x: 0, y: 15 },
                { x: 18, y: 5 },
                { x: -12, y: -8 },
                { x: 12, y: -12 },
                { x: 0, y: -20 },
                { x: -25, y: -2 },
                { x: 25, y: 2 }
            ];

            positions.forEach((pos, index) => {
                const figure = createFigure();
                figure.position.set(pos.x, pos.y, 0);
                figure.userData.originalPosition = pos;
                figure.userData.quantumState = Math.random() * Math.PI * 2;
                figure.userData.vibrationPhase = Math.random() * Math.PI * 2;
                scene.add(figure);
                figures.push(figure);
            });

            // Create quantum strings between all figures
            for (let i = 0; i < figures.length; i++) {
                for (let j = i + 1; j < figures.length; j++) {
                    createQuantumString(figures[i], figures[j], i, j);
                }
            }
        }

        function createFigure() {
            const figureGroup = new THREE.Group();
            
            // Body with quantum glow
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.8, 3.5, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.7
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            figureGroup.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.7, 8, 8);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 2.6;
            figureGroup.add(head);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2.2, 6);
            const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArm.position.set(-1.3, 1, 0);
            leftArm.rotation.z = 0.5;
            figureGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
            rightArm.position.set(1.3, 1, 0);
            rightArm.rotation.z = -0.5;
            figureGroup.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2.8, 6);
            const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            leftLeg.position.set(-0.4, -3.2, 0);
            figureGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            rightLeg.position.set(0.4, -3.2, 0);
            figureGroup.add(rightLeg);

            // Quantum aura
            const auraGeometry = new THREE.SphereGeometry(2.5, 16, 16);
            const auraMaterial = new THREE.MeshBasicMaterial({
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.03,
                wireframe: true
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            figureGroup.add(aura);

            figureGroup.scale.setScalar(0.35);
            return figureGroup;
        }

        function createQuantumString(figure1, figure2, index1, index2) {
            const distance = figure1.position.distanceTo(figure2.position);
            const segments = Math.floor(distance / 2) + 10; // More segments for smoother vibration
            
            // Create curve points for the string
            const curve = new THREE.CatmullRomCurve3([
                figure1.position.clone(),
                figure2.position.clone()
            ]);
            
            const points = curve.getPoints(segments);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const material = new THREE.LineBasicMaterial({
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.15
            });
            
            const string = new THREE.Line(geometry, material);
            string.userData = {
                figure1: figure1,
                figure2: figure2,
                index1: index1,
                index2: index2,
                segments: segments,
                vibrationFreq: 0.5 + Math.random() * 2,
                harmonics: Math.random() * 3 + 1,
                originalPoints: points.map(p => p.clone())
            };
            
            scene.add(string);
            strings.push(string);

            // Create quantum particles along string
            for (let i = 0; i < 3; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.08, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0.4
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.userData = {
                    stringIndex: strings.length - 1,
                    position: Math.random(),
                    speed: 0.01 + Math.random() * 0.02
                };
                scene.add(particle);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Update figure quantum states and positions
            figures.forEach((figure, index) => {
                // Quantum uncertainty - slight position oscillation
                const quantum = Math.sin(time * 2 + figure.userData.quantumState) * 0.3;
                const vibration = Math.sin(time * 8 + figure.userData.vibrationPhase) * 0.1;
                
                figure.position.x = figure.userData.originalPosition.x + quantum + vibration;
                figure.position.y = figure.userData.originalPosition.y + 
                    Math.cos(time * 1.5 + figure.userData.quantumState) * 0.2;
                
                // Quantum rotation
                figure.rotation.y = Math.sin(time * 0.5 + index) * 0.1;
                
                // Quantum scale pulsing
                const scale = 0.35 + Math.sin(time * 3 + figure.userData.vibrationPhase) * 0.02;
                figure.scale.setScalar(scale);
                
                // Update aura (last child)
                const aura = figure.children[figure.children.length - 1];
                aura.rotation.x = time * 0.2;
                aura.rotation.y = time * 0.15;
                aura.rotation.z = time * 0.1;
                aura.material.opacity = 0.02 + Math.sin(time * 2 + index) * 0.01;
            });

            // Update quantum strings with vibrations
            strings.forEach((string, stringIndex) => {
                const figure1 = string.userData.figure1;
                const figure2 = string.userData.figure2;
                
                // Calculate quantum entanglement strength
                const distance = figure1.position.distanceTo(figure2.position);
                const entanglement = Math.max(0, 1 - distance / 50);
                
                // Update string vibration
                const points = [];
                const segments = string.userData.segments;
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const basePoint = figure1.position.clone().lerp(figure2.position, t);
                    
                    // Multiple harmonic vibrations
                    let vibrationY = 0;
                    let vibrationZ = 0;
                    
                    for (let h = 1; h <= string.userData.harmonics; h++) {
                        const freq = string.userData.vibrationFreq * h;
                        const amplitude = entanglement * (0.5 / h) * Math.sin(Math.PI * t);
                        
                        vibrationY += amplitude * Math.sin(time * freq * 4 + stringIndex + h * Math.PI/3);
                        vibrationZ += amplitude * Math.cos(time * freq * 3 + stringIndex + h * Math.PI/4) * 0.3;
                    }
                    
                    // Add quantum uncertainty
                    const uncertainty = Math.sin(time * 10 + t * 8 + stringIndex) * 0.05 * entanglement;
                    
                    basePoint.y += vibrationY + uncertainty;
                    basePoint.z += vibrationZ;
                    
                    points.push(basePoint);
                }
                
                string.geometry.setFromPoints(points);
                
                // Update string opacity based on entanglement and vibration
                const vibrationIntensity = Math.abs(Math.sin(time * string.userData.vibrationFreq * 2 + stringIndex));
                string.material.opacity = 0.05 + entanglement * 0.2 + vibrationIntensity * 0.1;
                
                // Quantum resonance effect
                if (vibrationIntensity > 0.8) {
                    string.material.opacity += 0.1;
                }
            });

            // Update quantum particles
            scene.children.forEach(child => {
                if (child.userData.stringIndex !== undefined) {
                    const string = strings[child.userData.stringIndex];
                    if (string) {
                        // Move particle along string
                        child.userData.position += child.userData.speed;
                        if (child.userData.position > 1) {
                            child.userData.position = 0;
                        }
                        
                        // Get position on vibrating string
                        const points = string.geometry.attributes.position.array;
                        const segmentIndex = Math.floor(child.userData.position * (points.length / 3 - 1));
                        const segmentProgress = (child.userData.position * (points.length / 3 - 1)) % 1;
                        
                        if (segmentIndex < points.length / 3 - 1) {
                            const i1 = segmentIndex * 3;
                            const i2 = (segmentIndex + 1) * 3;
                            
                            child.position.x = points[i1] + (points[i2] - points[i1]) * segmentProgress;
                            child.position.y = points[i1 + 1] + (points[i2 + 1] - points[i1 + 1]) * segmentProgress;
                            child.position.z = points[i1 + 2] + (points[i2 + 2] - points[i1 + 2]) * segmentProgress;
                        }
                        
                        // Quantum interference pattern
                        const interference = Math.sin(child.userData.position * Math.PI * 4 + time * 5);
                        child.material.opacity = 0.2 + interference * 0.3;
                        child.scale.setScalar(0.08 + Math.abs(interference) * 0.04);
                    }
                }
            });

            // Mouse influence on quantum field
            if (mouse.length() > 0) {
                const mouseWorld = new THREE.Vector3(mouse.x * 25, mouse.y * 15, 0);
                
                figures.forEach(figure => {
                    const distance = figure.position.distanceTo(mouseWorld);
                    if (distance < 10) {
                        const influence = (10 - distance) / 10;
                        figure.userData.quantumState += influence * 0.1;
                        
                        // Quantum tunneling effect
                        const direction = mouseWorld.clone().sub(figure.position).normalize();
                        figure.position.add(direction.multiplyScalar(influence * 0.1));
                    }
                });
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        init();
    </script>
</body>
</html>