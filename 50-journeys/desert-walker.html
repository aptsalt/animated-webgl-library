<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Desert Walker - Journey Through Dunes</title>
    <style>
        body {
            margin: 0;
            background: #f8f8f8;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        canvas { display: block; }
        .title {
            position: absolute;
            top: 30px;
            left: 30px;
            color: #666;
            font-size: 24px;
            font-weight: 300;
            z-index: 100;
            opacity: 0;
            animation: fadeIn 3s ease-in-out 1s forwards;
        }
        .subtitle {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: #444;
            font-size: 14px;
            z-index: 100;
            opacity: 0;
            animation: fadeIn 3s ease-in-out 2s forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="title">Desert Walker</div>
    <div class="subtitle">Steps through endless sands</div>
    
    <script>
        let scene, camera, renderer;
        let walker;
        let dunes = [];
        let sandParticles;
        let time = 0;
        
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xf8f8f8, 5, 30);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 6, 10);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xf8f8f8);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Harsh desert sun
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(-10, 20, -5);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 50;
            sunLight.shadow.camera.left = -25;
            sunLight.shadow.camera.right = 25;
            sunLight.shadow.camera.top = 25;
            sunLight.shadow.camera.bottom = -25;
            scene.add(sunLight);
            
            // Ambient heat shimmer
            const ambientLight = new THREE.AmbientLight(0x808080, 0.6);
            scene.add(ambientLight);
            
            createDunes();
            createWalker();
            createSandParticles();
            
            animate();
        }
        
        function createDunes() {
            const dunePositions = [
                { x: -15, z: -10, scale: 1.2 },
                { x: -8, z: -5, scale: 0.8 },
                { x: 0, z: 0, scale: 1.0 },
                { x: 8, z: 5, scale: 1.5 },
                { x: 15, z: 10, scale: 0.9 },
                { x: -20, z: 15, scale: 1.1 },
                { x: 12, z: -15, scale: 1.3 }
            ];
            
            dunePositions.forEach(pos => {
                // Create organic dune shape
                const duneGeometry = new THREE.SphereGeometry(3, 16, 8);
                
                // Flatten the sphere to make it dune-like
                const positionAttribute = duneGeometry.attributes.position;
                for (let i = 0; i < positionAttribute.count; i++) {
                    const y = positionAttribute.getY(i);
                    if (y < 0) {
                        positionAttribute.setY(i, y * 0.1); // Flatten bottom
                    }
                }
                positionAttribute.needsUpdate = true;
                
                const duneMaterial = new THREE.MeshLambertMaterial({
                    color: 0xd5d0c8,
                    transparent: true,
                    opacity: 0.7
                });
                
                const dune = new THREE.Mesh(duneGeometry, duneMaterial);
                dune.position.set(pos.x, -1, pos.z);
                dune.scale.set(pos.scale, pos.scale * 0.6, pos.scale);
                dune.receiveShadow = true;
                
                // Add subtle noise to dune surface
                dune.rotation.y = Math.random() * Math.PI * 2;
                
                scene.add(dune);
                dunes.push(dune);
            });
        }
        
        function createWalker() {
            const group = new THREE.Group();
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.95
            });
            
            // Head with head wrap
            const headGeometry = new THREE.SphereGeometry(0.1, 8, 6);
            const head = new THREE.Mesh(headGeometry, material);
            head.position.y = 0.6;
            group.add(head);
            
            // Head wrap/turban
            const wrapGeometry = new THREE.SphereGeometry(0.12, 8, 6);
            const wrapMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x222222,
                transparent: true,
                opacity: 0.8
            });
            const wrap = new THREE.Mesh(wrapGeometry, wrapMaterial);
            wrap.position.y = 0.6;
            wrap.scale.y = 0.8;
            group.add(wrap);
            
            // Body in robes
            const bodyGeometry = new THREE.CylinderGeometry(0.09, 0.15, 0.5, 8);
            const body = new THREE.Mesh(bodyGeometry, material);
            body.position.y = 0.25;
            group.add(body);
            
            // Flowing robes
            const robeGeometry = new THREE.ConeGeometry(0.18, 0.4, 12);
            const robeMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2a2a2a,
                transparent: true,
                opacity: 0.7
            });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 0.1;
            group.add(robe);
            
            // Arms under robes
            const armGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.3, 6);
            const leftArm = new THREE.Mesh(armGeometry, material);
            const rightArm = new THREE.Mesh(armGeometry, material);
            leftArm.position.set(-0.12, 0.3, 0);
            rightArm.position.set(0.12, 0.3, 0);
            leftArm.rotation.z = 0.2;
            rightArm.rotation.z = -0.2;
            group.add(leftArm);
            group.add(rightArm);
            
            // Walking staff
            const staffGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1.2, 8);
            const staffMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const staff = new THREE.Mesh(staffGeometry, staffMaterial);
            staff.position.set(0.15, 0.4, 0);
            staff.rotation.z = -0.2;
            group.add(staff);
            
            // Legs (barely visible under robes)
            const legGeometry = new THREE.CylinderGeometry(0.04, 0.05, 0.3, 6);
            const leftLeg = new THREE.Mesh(legGeometry, material);
            const rightLeg = new THREE.Mesh(legGeometry, material);
            leftLeg.position.set(-0.05, -0.15, 0);
            rightLeg.position.set(0.05, -0.15, 0);
            group.add(leftLeg);
            group.add(rightLeg);
            
            walker = group;
            walker.castShadow = true;
            walker.position.set(0, 0.5, 0);
            scene.add(walker);
        }
        
        function createSandParticles() {
            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 1] = Math.random() * 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xc0b8a8,
                size: 0.02,
                transparent: true,
                opacity: 0.4
            });
            
            sandParticles = new THREE.Points(geometry, material);
            scene.add(sandParticles);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.01;
            
            // Walker movement - slow, steady progress across dunes
            const walkSpeed = time * 0.2;
            walker.position.x = Math.sin(walkSpeed * 0.3) * 8;
            walker.position.z = walkSpeed % 40 - 20; // Move forward and loop back
            
            // Calculate height based on dune positions
            let groundHeight = 0;
            dunes.forEach(dune => {
                const distance = Math.sqrt(
                    Math.pow(walker.position.x - dune.position.x, 2) + 
                    Math.pow(walker.position.z - dune.position.z, 2)
                );
                if (distance < 3 * dune.scale.x) {
                    const influence = (3 * dune.scale.x - distance) / (3 * dune.scale.x);
                    groundHeight += influence * 1.5 * dune.scale.y;
                }
            });
            
            walker.position.y = groundHeight + 0.5 + Math.sin(time * 6) * 0.03; // Walking bob
            
            // Walking animation
            const walkCycle = Math.sin(time * 8);
            walker.children[7].rotation.x = walkCycle * 0.3; // Left leg
            walker.children[8].rotation.x = -walkCycle * 0.3; // Right leg
            
            // Arm movement with staff
            walker.children[4].rotation.x = -walkCycle * 0.2; // Left arm
            walker.children[5].rotation.x = walkCycle * 0.1; // Right arm
            walker.children[6].rotation.z = -0.2 + walkCycle * 0.1; // Staff sway
            
            // Robe sway in desert wind
            walker.children[3].rotation.x = Math.sin(time * 3) * 0.1;
            walker.children[3].rotation.z = Math.sin(time * 2) * 0.05;
            
            // Head wrap flutter
            walker.children[1].rotation.y = Math.sin(time * 4) * 0.05;
            
            // Animate sand particles (wind effect)
            const positions = sandParticles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] += Math.sin(time + i) * 0.01; // X drift
                positions[i + 1] += (Math.random() - 0.5) * 0.02; // Y float
                positions[i + 2] += Math.sin(time * 0.5 + i) * 0.005; // Z drift
                
                // Reset particles that drift too far
                if (positions[i] > 25) positions[i] = -25;
                if (positions[i] < -25) positions[i] = 25;
                if (positions[i + 1] > 12) positions[i + 1] = 0;
                if (positions[i + 1] < 0) positions[i + 1] = 12;
                if (positions[i + 2] > 25) positions[i + 2] = -25;
                if (positions[i + 2] < -25) positions[i + 2] = 25;
            }
            sandParticles.geometry.attributes.position.needsUpdate = true;
            
            // Dune subtle movement (heat shimmer effect)
            dunes.forEach((dune, index) => {
                dune.position.y = -1 + Math.sin(time + index) * 0.05;
            });
            
            // Camera follows walker with cinematic movement
            camera.position.x = walker.position.x + Math.sin(time * 0.3) * 3 + 5;
            camera.position.z = walker.position.z + 8 + Math.cos(time * 0.2) * 2;
            camera.position.y = 6 + Math.sin(time * 0.4) * 1;
            camera.lookAt(walker.position);
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize, false);
        
        init();
    </script>
</body>
</html>