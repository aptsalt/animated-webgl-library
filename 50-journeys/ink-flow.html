<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ink Flow - Mindful Journey</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #fafafa;
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid rgba(26, 26, 26, 0.2);
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .back-btn:hover {
            background: rgba(26, 26, 26, 0.05);
            border-color: rgba(26, 26, 26, 0.4);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">‚Üê Back</a>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let inkFlows = [];
        let time = 0;
        let inkGroup;  // Group to contain all ink flows for easy transformation
        const animationDuration = 12;  // 12 seconds animation - very slow

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfafafa);

            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create a group to contain all ink flows
            inkGroup = new THREE.Group();
            scene.add(inkGroup);
            
            createInkFlows();
            animate();
        }

        function createInkFlows() {
            const flowCount = 3;  // Minimized count for distant effect
            
            for (let i = 0; i < flowCount; i++) {
                const points = [];
                for (let j = 0; j <= 80; j++) {  // More points for longer lines
                    const x = (j - 40) * 0.3;  // Longer scale
                    const y = 0;
                    const z = i * 1 - 1;  // Closer spacing, smaller depth
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0.2 - i * 0.02,  // Lower opacity for distant effect
                    linewidth: 1  // Thinner lines
                });
                
                const flow = new THREE.Line(geometry, material);
                flow.userData = {
                    phase: i * 0.5,
                    amplitude: 0.8 + i * 0.2,  // Much more wavy amplitude
                    speed: 0.2 + i * 0.02,  // Much slower speed
                    points: points,
                    originalY: []
                };
                
                // Store original Y positions
                for (let k = 0; k < points.length; k++) {
                    flow.userData.originalY.push(points[k].y);
                }
                
                inkGroup.add(flow);  // Add to group instead of scene
                inkFlows.push(flow);
                
                // Add ink particles
                createInkParticles(i);
            }
        }

        function createInkParticles(flowIndex) {
            const particleCount = 10;  // Reduced particle count
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.CircleGeometry(Math.random() * 0.1 + 0.02, 8);  // More segments for smoother circles
                
                // Create material with darker border effect
                const canvas = document.createElement('canvas');
                const size = 32;
                canvas.width = canvas.height = size;
                const context = canvas.getContext('2d');
                
                // Create gradient for border effect - much darker
                const gradient = context.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                gradient.addColorStop(0, 'rgba(26, 26, 26, 1.0)');
                gradient.addColorStop(0.5, 'rgba(26, 26, 26, 0.8)');
                gradient.addColorStop(1, 'rgba(26, 26, 26, 0.3)');
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, size, size);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: Math.random() * 0.3 + 0.2  // Much higher opacity for darker dots
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set(
                    (Math.random() - 0.5) * 15,  // Slightly larger spread for longer lines
                    0,
                    flowIndex * 1 - 1 + (Math.random() - 0.5) * 0.5  // Adjusted for new positioning
                );
                
                particle.userData = {
                    phase: Math.random() * Math.PI * 2,
                    flowIndex: flowIndex,
                    baseOpacity: material.opacity,
                    driftSpeed: Math.random() * 0.1 + 0.05  // Much slower drift
                };
                
                inkGroup.add(particle);  // Add to group
                particles.push(particle);
            }
            
            inkFlows.push({ particles: particles, isParticleGroup: true });
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.005;
            
            // 3-second animation: start far away at top right, move closer
            const animationProgress = Math.min(time / animationDuration, 1);
            const easeProgress = 1 - Math.pow(1 - animationProgress, 3);  // Ease out cubic
            
            // Starting position: far away, top right
            const startX = 8;
            const startY = 5;
            const startZ = -30;
            const startScale = 0.3;
            
            // Ending position: close to viewer
            const endX = 1;
            const endY = 0.5;
            const endZ = -4;
            const endScale = 1.4;
            
            // Interpolate position and scale
            inkGroup.position.x = startX + (endX - startX) * easeProgress;
            inkGroup.position.y = startY + (endY - startY) * easeProgress;
            inkGroup.position.z = startZ + (endZ - startZ) * easeProgress;
            inkGroup.scale.setScalar(startScale + (endScale - startScale) * easeProgress);

            inkFlows.forEach((item, index) => {
                if (item instanceof THREE.Line) {
                    // Animate flowing lines
                    const flow = item;
                    const positions = flow.geometry.attributes.position;
                    
                    for (let i = 0; i < positions.count; i++) {
                        const x = positions.getX(i);
                        const y = Math.sin(x * 0.15 + time * flow.userData.speed + flow.userData.phase) * flow.userData.amplitude;
                        const flowY = Math.sin(time * 0.4 + i * 0.05) * 0.3;  // More wavy flow
                        const disperseY = Math.sin(time * 0.3 + x * 0.08) * 0.2;  // More wavy dispersion
                        
                        positions.setY(i, y + flowY + disperseY);
                    }
                    positions.needsUpdate = true;
                    
                    // Very subtle opacity pulse
                    const baseOpacity = 0.2 - (index * 0.02);
                    flow.material.opacity = baseOpacity + Math.sin(time * 0.3 + flow.userData.phase) * 0.03;
                    
                } else if (item.isParticleGroup) {
                    // Animate ink particles
                    item.particles.forEach(particle => {
                        // Very subtle drift motion
                        particle.position.x += Math.sin(time * particle.userData.driftSpeed + particle.userData.phase) * 0.002;
                        particle.position.y = Math.sin(time * 0.1 + particle.userData.phase) * 0.3;
                        
                        // Wrap around (smaller bounds)
                        if (particle.position.x > 5) particle.position.x = -5;
                        if (particle.position.x < -5) particle.position.x = 5;
                        
                        // Very subtle opacity changes
                        particle.material.opacity = particle.userData.baseOpacity * 
                            (0.8 + Math.sin(time * 0.2 + particle.userData.phase) * 0.2);
                        
                        // Minimal scale changes
                        const scale = 1 + Math.sin(time * 0.5 + particle.userData.phase) * 0.05;
                        particle.scale.set(scale, scale, 1);
                    });
                }
            });

            // Very subtle camera movement
            camera.position.x = Math.sin(time * 0.02) * 0.5;
            camera.position.y = Math.sin(time * 0.03) * 0.3;
            camera.lookAt(inkGroup.position);  // Look at the ink group

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('mousemove', (event) => {
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            inkFlows.forEach((item, index) => {
                if (item instanceof THREE.Line) {
                    item.rotation.y = mouseX * 0.1;
                    // Removed vertical rotation for cleaner effect
                }
            });
        });

        init();
    </script>
</body>
</html>