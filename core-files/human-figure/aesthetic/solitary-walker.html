<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solitary Walker - Aesthetic Human Figure</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(180deg, #e8e8e8 0%, #f5f5f5 100%);
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid rgba(26, 26, 26, 0.1);
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .back-btn:hover {
            background: rgba(26, 26, 26, 0.05);
            border-color: rgba(26, 26, 26, 0.2);
        }
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(26, 26, 26, 0.4);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <a href="../index.html" class="back-btn">‚Üê Back</a>
    <div class="instruction">Click to interact with the scene</div>

    <script>
        let scene, camera, renderer;
        let walker, shadow;
        let time = 0;
        let walkCycle = 0;
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);
            
            createWalker();
            createShadow();
            animate();
        }
        
        function createWalker() {
            const group = new THREE.Group();
            
            const material = new THREE.MeshBasicMaterial({
                color: 0x1a1a1a,
                side: THREE.DoubleSide
            });
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 8, 6);
            const head = new THREE.Mesh(headGeometry, material);
            head.position.y = 1.75;
            head.castShadow = true;
            group.add(head);
            
            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.8, 6);
            const torso = new THREE.Mesh(torsoGeometry, material);
            torso.position.y = 1.1;
            torso.castShadow = true;
            group.add(torso);
            
            // Left arm
            const leftArmGroup = new THREE.Group();
            const upperArmGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 4);
            const upperArm = new THREE.Mesh(upperArmGeometry, material);
            upperArm.position.y = -0.2;
            upperArm.castShadow = true;
            leftArmGroup.add(upperArm);
            
            const lowerArmGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 4);
            const lowerArm = new THREE.Mesh(lowerArmGeometry, material);
            lowerArm.position.y = -0.6;
            lowerArm.castShadow = true;
            leftArmGroup.add(lowerArm);
            
            leftArmGroup.position.set(-0.25, 1.3, 0);
            leftArmGroup.userData = { type: 'leftArm' };
            group.add(leftArmGroup);
            
            // Right arm
            const rightArmGroup = new THREE.Group();
            const upperArmR = new THREE.Mesh(upperArmGeometry, material);
            upperArmR.position.y = -0.2;
            upperArmR.castShadow = true;
            rightArmGroup.add(upperArmR);
            
            const lowerArmR = new THREE.Mesh(lowerArmGeometry, material);
            lowerArmR.position.y = -0.6;
            lowerArmR.castShadow = true;
            rightArmGroup.add(lowerArmR);
            
            rightArmGroup.position.set(0.25, 1.3, 0);
            rightArmGroup.userData = { type: 'rightArm' };
            group.add(rightArmGroup);
            
            // Left leg
            const leftLegGroup = new THREE.Group();
            const upperLegGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 4);
            const upperLeg = new THREE.Mesh(upperLegGeometry, material);
            upperLeg.position.y = -0.25;
            upperLeg.castShadow = true;
            leftLegGroup.add(upperLeg);
            
            const lowerLegGeometry = new THREE.CylinderGeometry(0.06, 0.07, 0.5, 4);
            const lowerLeg = new THREE.Mesh(lowerLegGeometry, material);
            lowerLeg.position.y = -0.75;
            lowerLeg.castShadow = true;
            leftLegGroup.add(lowerLeg);
            
            leftLegGroup.position.set(-0.12, 0.7, 0);
            leftLegGroup.userData = { type: 'leftLeg' };
            group.add(leftLegGroup);
            
            // Right leg
            const rightLegGroup = new THREE.Group();
            const upperLegR = new THREE.Mesh(upperLegGeometry, material);
            upperLegR.position.y = -0.25;
            upperLegR.castShadow = true;
            rightLegGroup.add(upperLegR);
            
            const lowerLegR = new THREE.Mesh(lowerLegGeometry, material);
            lowerLegR.position.y = -0.75;
            lowerLegR.castShadow = true;
            rightLegGroup.add(lowerLegR);
            
            rightLegGroup.position.set(0.12, 0.7, 0);
            rightLegGroup.userData = { type: 'rightLeg' };
            group.add(rightLegGroup);
            
            walker = group;
            scene.add(walker);
        }
        
        function createShadow() {
            const shadowGeometry = new THREE.PlaneGeometry(1.5, 0.8);
            const shadowMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
            shadow.rotation.x = -Math.PI / 2;
            shadow.position.y = 0.01;
            scene.add(shadow);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            walkCycle += 0.03;
            
            if (walker) {
                // Walking animation
                const leftArm = walker.children.find(c => c.userData.type === 'leftArm');
                const rightArm = walker.children.find(c => c.userData.type === 'rightArm');
                const leftLeg = walker.children.find(c => c.userData.type === 'leftLeg');
                const rightLeg = walker.children.find(c => c.userData.type === 'rightLeg');
                
                // Arm swing
                if (leftArm) leftArm.rotation.x = Math.sin(walkCycle) * 0.4;
                if (rightArm) rightArm.rotation.x = -Math.sin(walkCycle) * 0.4;
                
                // Leg movement
                if (leftLeg) leftLeg.rotation.x = -Math.sin(walkCycle) * 0.5;
                if (rightLeg) rightLeg.rotation.x = Math.sin(walkCycle) * 0.5;
                
                // Subtle body movement
                walker.position.y = Math.abs(Math.sin(walkCycle * 2)) * 0.05;
                walker.rotation.y = Math.sin(time * 0.5) * 0.1;
                
                // Forward movement
                walker.position.z = Math.sin(time * 0.3) * 2;
                walker.position.x = Math.cos(time * 0.2) * 3;
            }
            
            // Shadow follows walker
            if (shadow && walker) {
                shadow.position.x = walker.position.x;
                shadow.position.z = walker.position.z + 0.3;
                shadow.scale.x = 1 + Math.abs(Math.sin(walkCycle * 2)) * 0.1;
            }
            
            // Camera subtle movement
            camera.position.x = Math.sin(time * 0.1) * 2;
            camera.position.y = 5 + Math.sin(time * 0.15) * 0.5;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        init();
    </script>
</body>
</html>