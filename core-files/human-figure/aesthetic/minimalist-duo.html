<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimalist Duo - Aesthetic Connection</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(180deg, #fafafa 0%, #f0f0f0 50%, #e8e8e8 100%);
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid rgba(26, 26, 26, 0.08);
            color: #1a1a1a;
            text-decoration: none;
            font-size: 13px;
            letter-spacing: 1.5px;
            border-radius: 20px;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
            backdrop-filter: blur(10px);
        }
        
        .back-btn:hover {
            background: rgba(255, 255, 255, 0.8);
            border-color: rgba(26, 26, 26, 0.15);
            transform: translateY(-2px);
        }
        
        .info {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(26, 26, 26, 0.3);
            font-size: 11px;
            letter-spacing: 3px;
            text-transform: uppercase;
            pointer-events: none;
            animation: fadeIn 2s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <a href="../index.html" class="back-btn">‚Üê Back</a>
    <div class="info">Silent Connection</div>
    
    <script>
        let scene, camera, renderer;
        let figure1, figure2;
        let particles = [];
        let connectionParticles = [];
        let time = 0;
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f8f8);
            
            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 18);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // Refined lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            createRefinedFigures();
            createConnectionParticles();
            createAmbientParticles();
            animate();
        }
        
        function createRefinedFigure() {
            const group = new THREE.Group();
            
            // More refined material with subtle gradient
            const material = new THREE.MeshPhongMaterial({
                color: 0x1a1a1a,
                specular: 0x222222,
                shininess: 10,
                flatShading: false
            });
            
            // Head - refined proportions
            const headGeometry = new THREE.SphereGeometry(0.22, 32, 24);
            const head = new THREE.Mesh(headGeometry, material);
            head.position.y = 1.85;
            head.scale.set(1, 1.1, 0.95);
            head.castShadow = true;
            head.receiveShadow = true;
            group.add(head);
            
            // Neck
            const neckGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.2, 16);
            const neck = new THREE.Mesh(neckGeometry, material);
            neck.position.y = 1.55;
            neck.castShadow = true;
            group.add(neck);
            
            // Upper body - more human-like
            const upperBodyGeometry = new THREE.CylinderGeometry(0.18, 0.22, 0.6, 20);
            const upperBody = new THREE.Mesh(upperBodyGeometry, material);
            upperBody.position.y = 1.2;
            upperBody.scale.set(1.1, 1, 0.8);
            upperBody.castShadow = true;
            group.add(upperBody);
            
            // Lower body
            const lowerBodyGeometry = new THREE.CylinderGeometry(0.22, 0.18, 0.5, 20);
            const lowerBody = new THREE.Mesh(lowerBodyGeometry, material);
            lowerBody.position.y = 0.75;
            lowerBody.castShadow = true;
            group.add(lowerBody);
            
            // Arms - simplified elegant lines
            const armGeometry = new THREE.CylinderGeometry(0.04, 0.05, 0.7, 12);
            
            const leftArm = new THREE.Mesh(armGeometry, material);
            leftArm.position.set(-0.22, 1.1, 0);
            leftArm.rotation.z = 0.15;
            leftArm.castShadow = true;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, material);
            rightArm.position.set(0.22, 1.1, 0);
            rightArm.rotation.z = -0.15;
            rightArm.castShadow = true;
            group.add(rightArm);
            
            // Legs - refined proportions
            const legGeometry = new THREE.CylinderGeometry(0.06, 0.08, 1, 12);
            
            const leftLeg = new THREE.Mesh(legGeometry, material);
            leftLeg.position.set(-0.1, 0.25, 0);
            leftLeg.castShadow = true;
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, material);
            rightLeg.position.set(0.1, 0.25, 0);
            rightLeg.castShadow = true;
            group.add(rightLeg);
            
            // Refined shadow
            const shadowGeometry = new THREE.PlaneGeometry(1.5, 1.5);
            const shadowMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.08,
                side: THREE.DoubleSide
            });
            const shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
            shadow.rotation.x = -Math.PI / 2;
            shadow.position.y = 0.001;
            group.add(shadow);
            
            return group;
        }
        
        function createRefinedFigures() {
            // First figure
            figure1 = createRefinedFigure();
            figure1.position.x = -3;
            figure1.position.z = 0.5;
            figure1.userData = {
                baseX: -3,
                baseZ: 0.5,
                movePhase: 0,
                breathPhase: 0
            };
            scene.add(figure1);
            
            // Second figure
            figure2 = createRefinedFigure();
            figure2.position.x = 3;
            figure2.position.z = -0.5;
            figure2.userData = {
                baseX: 3,
                baseZ: -0.5,
                movePhase: Math.PI,
                breathPhase: Math.PI
            };
            scene.add(figure2);
        }
        
        function createConnectionParticles() {
            // Create subtle particle connection between figures
            const particleCount = 20;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 6;
                positions[i * 3 + 1] = 1 + (Math.random() - 0.5) * 2;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
                sizes[i] = Math.random() * 0.03 + 0.01;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.02,
                color: 0x404040,
                transparent: true,
                opacity: 0.3,
                sizeAttenuation: true
            });
            
            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            connectionParticles.push(particleSystem);
        }
        
        function createAmbientParticles() {
            // Create floating ambient particles
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 20;
                positions[i * 3 + 1] = Math.random() * 5;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
                sizes[i] = Math.random() * 0.02 + 0.005;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.01,
                color: 0x808080,
                transparent: true,
                opacity: 0.2,
                sizeAttenuation: true
            });
            
            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            particles.push(particleSystem);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.008;
            
            // Animate figure 1 with more refined motion
            if (figure1) {
                // Elegant approach and retreat
                const moveX = Math.sin(time + figure1.userData.movePhase) * 0.8;
                const moveZ = Math.cos(time * 0.7 + figure1.userData.movePhase) * 0.3;
                figure1.position.x = figure1.userData.baseX + moveX;
                figure1.position.z = figure1.userData.baseZ + moveZ;
                
                // Subtle vertical breathing
                figure1.position.y = Math.sin(time * 1.2 + figure1.userData.breathPhase) * 0.03;
                
                // Gentle turning
                figure1.rotation.y = Math.sin(time * 0.4) * 0.15 + moveX * 0.1;
                
                // Natural breathing scale
                const breathScale = 1 + Math.sin(time * 2 + figure1.userData.breathPhase) * 0.015;
                figure1.scale.set(breathScale, breathScale * 1.02, breathScale);
                
                // Arm sway
                const leftArm = figure1.children[4];
                const rightArm = figure1.children[5];
                if (leftArm) leftArm.rotation.x = Math.sin(time * 1.5) * 0.05;
                if (rightArm) rightArm.rotation.x = -Math.sin(time * 1.5) * 0.05;
                
                // Update shadow
                const shadow1 = figure1.children[8];
                if (shadow1) {
                    shadow1.scale.x = 1.5 + Math.abs(moveX) * 0.3;
                    shadow1.scale.z = 1.5 + Math.abs(moveZ) * 0.2;
                    shadow1.material.opacity = 0.08 - Math.abs(figure1.position.y) * 0.02;
                }
            }
            
            // Animate figure 2 with complementary motion
            if (figure2) {
                // Mirrored approach and retreat
                const moveX = -Math.sin(time + figure2.userData.movePhase) * 0.8;
                const moveZ = -Math.cos(time * 0.7 + figure2.userData.movePhase) * 0.3;
                figure2.position.x = figure2.userData.baseX + moveX;
                figure2.position.z = figure2.userData.baseZ + moveZ;
                
                // Opposite breathing
                figure2.position.y = -Math.sin(time * 1.2 + figure2.userData.breathPhase) * 0.03;
                
                // Opposite turning
                figure2.rotation.y = -Math.sin(time * 0.4) * 0.15 + moveX * 0.1;
                
                // Complementary breathing
                const breathScale = 1 - Math.sin(time * 2 + figure2.userData.breathPhase) * 0.015;
                figure2.scale.set(breathScale, breathScale * 1.02, breathScale);
                
                // Arm sway
                const leftArm = figure2.children[4];
                const rightArm = figure2.children[5];
                if (leftArm) leftArm.rotation.x = -Math.sin(time * 1.5) * 0.05;
                if (rightArm) rightArm.rotation.x = Math.sin(time * 1.5) * 0.05;
                
                // Update shadow
                const shadow2 = figure2.children[8];
                if (shadow2) {
                    shadow2.scale.x = 1.5 + Math.abs(moveX) * 0.3;
                    shadow2.scale.z = 1.5 + Math.abs(moveZ) * 0.2;
                    shadow2.material.opacity = 0.08 - Math.abs(figure2.position.y) * 0.02;
                }
            }
            
            // Animate connection particles
            connectionParticles.forEach(system => {
                const positions = system.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    // Flow between figures
                    const t = (i / 3) / (positions.length / 3);
                    const flowX = figure1.position.x + (figure2.position.x - figure1.position.x) * t;
                    const flowY = 1 + Math.sin(time * 2 + t * Math.PI * 2) * 0.3;
                    const flowZ = figure1.position.z + (figure2.position.z - figure1.position.z) * t;
                    
                    positions[i] = flowX + Math.sin(time * 3 + i) * 0.2;
                    positions[i + 1] = flowY;
                    positions[i + 2] = flowZ + Math.cos(time * 3 + i) * 0.2;
                }
                system.geometry.attributes.position.needsUpdate = true;
                
                // Fade based on figure distance
                const distance = figure1.position.distanceTo(figure2.position);
                system.material.opacity = Math.max(0, (8 - distance) / 8) * 0.3;
            });
            
            // Animate ambient particles
            particles.forEach(system => {
                const positions = system.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += Math.sin(time + i) * 0.002;
                    if (positions[i + 1] > 5) positions[i + 1] = 0;
                }
                system.geometry.attributes.position.needsUpdate = true;
                system.rotation.y = time * 0.05;
            });
            
            // Camera subtle movement
            camera.position.x = Math.sin(time * 0.15) * 2;
            camera.position.y = 2 + Math.sin(time * 0.2) * 0.8;
            camera.position.z = 18 + Math.cos(time * 0.1) * 3;
            camera.lookAt(0, 1, 0);
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        init();
    </script>
</body>
</html>