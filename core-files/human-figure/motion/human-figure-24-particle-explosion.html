<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Human Figure Particle Explosion - Mindful Journey</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #0d0d0d;
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid rgba(255, 165, 0, 0.4);
            color: #ffa500;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .back-btn:hover {
            background: rgba(255, 165, 0, 0.1);
            border-color: rgba(255, 165, 0, 0.8);
        }
        
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 165, 0, 0.8);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-btn">‚Üê Back</a>
    <div class="instruction">Click to explode and reform</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="../lib/theme-system.js"></script>
    <script>
        let scene, camera, renderer;
        let humanFigure;
        let particles = [];
        let time = 0;
        let exploding = false;
        let explosionProgress = 0;
        let reforming = false;
        let reformProgress = 0;
        let themeSystem;
        let materials = [];

        function init() {
            // Initialize theme system
            themeSystem = new HumanFigureThemeSystem();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d0d0d);

            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.z = 12;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createHumanFigure();
            createParticleSystem();
            setupThemeEventListeners();
            animate();
        }
        
        function setupThemeEventListeners() {
            window.addEventListener('themeChanged', (event) => {
                const { theme, palette } = event.detail;
                updateFigureWithTheme(theme, palette);
            });
            
            window.addEventListener('paletteChanged', (event) => {
                const { palette } = event.detail;
                updateFigureWithPalette(palette);
            });
        }
        
        function updateFigureWithTheme(theme, palette) {
            // Update figure with new theme
            if (humanFigure && humanFigure.userData.bodyParts) {
                humanFigure.userData.bodyParts.forEach(particle => {
                    if (particle.material) {
                        particle.material.opacity = theme.particleOpacity || 0.8;
                        particle.material.transparent = true;
                    }
                });
            }
            
            // Update scene background
            scene.background.setHex(parseInt(palette.background.replace('#', ''), 16));
        }
        
        function updateFigureWithPalette(palette) {
            // Update scene background
            scene.background.setHex(parseInt(palette.background.replace('#', ''), 16));
            
            // Update particle colors
            if (humanFigure && humanFigure.userData.bodyParts) {
                humanFigure.userData.bodyParts.forEach((particle, index) => {
                    const colorIndex = index % palette.gradient.length;
                    const color = palette.gradient[colorIndex];
                    particle.material.color.setHex(parseInt(color.replace('#', ''), 16));
                });
            }
        }

        function createHumanFigure() {
            const group = new THREE.Group();
            
            const bodyParts = [];
            
            // Create figure with more particles for explosion effect
            const currentPalette = themeSystem.getCurrentPalette();
            const colors = currentPalette.gradient.map(color => parseInt(color.replace('#', ''), 16));
            
            // Head
            for (let i = 0; i < 50; i++) {
                const currentTheme = themeSystem.getCurrentTheme();
                const material = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: currentTheme.particleOpacity || 0.8
                });
                materials.push(material);
                
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(currentTheme.particleSize || 0.02, 4, 3),
                    material
                );
                
                const phi = Math.acos(-1 + (2 * i) / 50);
                const theta = Math.sqrt(50 * Math.PI) * phi;
                const radius = 0.4;
                
                particle.position.set(
                    radius * Math.cos(theta) * Math.sin(phi),
                    2.5 + radius * Math.sin(theta) * Math.sin(phi),
                    radius * Math.cos(phi)
                );
                
                particle.userData = {
                    originalPos: particle.position.clone(),
                    bodyPart: 'head',
                    explosionVelocity: particle.position.clone().normalize().multiplyScalar(5 + Math.random() * 10)
                };
                
                group.add(particle);
                bodyParts.push(particle);
            }
            
            // Torso
            for (let i = 0; i < 80; i++) {
                const currentTheme = themeSystem.getCurrentTheme();
                const material = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: currentTheme.particleOpacity || 0.8
                });
                materials.push(material);
                
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(currentTheme.particleSize || 0.025, 4, 3),
                    material
                );
                
                const angle = (i / 80) * Math.PI * 2;
                const height = (i / 80) * 1.5;
                const radius = 0.3 + Math.sin(height * 2) * 0.1;
                
                particle.position.set(
                    Math.cos(angle) * radius + (Math.random() - 0.5) * 0.2,
                    2 - height,
                    Math.sin(angle) * radius + (Math.random() - 0.5) * 0.2
                );
                
                particle.userData = {
                    originalPos: particle.position.clone(),
                    bodyPart: 'torso',
                    explosionVelocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 15
                    )
                };
                
                group.add(particle);
                bodyParts.push(particle);
            }
            
            // Arms and legs
            ['leftArm', 'rightArm', 'leftLeg', 'rightLeg'].forEach((limb, limbIndex) => {
                for (let i = 0; i < 30; i++) {
                    const currentTheme = themeSystem.getCurrentTheme();
                    const material = new THREE.MeshBasicMaterial({
                        color: colors[Math.floor(Math.random() * colors.length)],
                        transparent: true,
                        opacity: currentTheme.particleOpacity || 0.8
                    });
                    materials.push(material);
                    
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(currentTheme.particleSize || 0.02, 4, 3),
                        material
                    );
                    
                    let basePos;
                    switch(limb) {
                        case 'leftArm':
                            basePos = new THREE.Vector3(-0.5 - i * 0.02, 1.8 - i * 0.01, 0);
                            break;
                        case 'rightArm':
                            basePos = new THREE.Vector3(0.5 + i * 0.02, 1.8 - i * 0.01, 0);
                            break;
                        case 'leftLeg':
                            basePos = new THREE.Vector3(-0.15, 0.5 - i * 0.03, 0);
                            break;
                        case 'rightLeg':
                            basePos = new THREE.Vector3(0.15, 0.5 - i * 0.03, 0);
                            break;
                    }
                    
                    particle.position.copy(basePos).add(
                        new THREE.Vector3(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1
                        )
                    );
                    
                    particle.userData = {
                        originalPos: particle.position.clone(),
                        bodyPart: limb,
                        explosionVelocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20
                        )
                    };
                    
                    group.add(particle);
                    bodyParts.push(particle);
                }
            });
            
            group.userData.bodyParts = bodyParts;
            scene.add(group);
            humanFigure = group;
        }

        function createParticleSystem() {
            // Additional environmental particles for dramatic effect
            for (let i = 0; i < 500; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.01, 3, 2),
                    new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.1 + Math.random() * 0.2, 0.8, 0.7),
                        transparent: true,
                        opacity: 0
                    })
                );
                
                particle.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50
                );
                
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1
                    ),
                    life: Math.random(),
                    maxLife: 1 + Math.random() * 2
                };
                
                scene.add(particle);
                particles.push(particle);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Handle explosion state
            if (exploding) {
                explosionProgress += 0.02;
                if (explosionProgress >= 1) {
                    exploding = false;
                    reforming = true;
                    reformProgress = 0;
                }
            }

            // Handle reformation state
            if (reforming) {
                reformProgress += 0.015;
                if (reformProgress >= 1) {
                    reforming = false;
                    explosionProgress = 0;
                    reformProgress = 0;
                }
            }

            // Apply theme-specific animation
            const animationFn = themeSystem.getAnimationFunction();
            if (humanFigure) {
                animationFn(humanFigure, time);
            }
            
            // Animate human figure particles
            humanFigure.userData.bodyParts.forEach((particle, index) => {
                if (exploding) {
                    // Explosion animation
                    const velocity = particle.userData.explosionVelocity.clone();
                    velocity.multiplyScalar(explosionProgress * 0.1);
                    particle.position.add(velocity);
                    
                    // Add some turbulence
                    particle.position.x += Math.sin(time * 5 + index) * 0.02 * explosionProgress;
                    particle.position.y += Math.cos(time * 5 + index) * 0.02 * explosionProgress;
                    
                    // Fade and scale
                    particle.material.opacity = 0.8 * (1 - explosionProgress * 0.5);
                    particle.scale.setScalar(1 + explosionProgress * 3);
                    
                    // Color shift to white-hot
                    particle.material.color.lerp(new THREE.Color(0xffffff), explosionProgress * 0.5);
                    
                } else if (reforming) {
                    // Reformation animation
                    const targetPos = particle.userData.originalPos;
                    particle.position.lerp(targetPos, reformProgress * 0.1);
                    
                    // Restore opacity and scale
                    particle.material.opacity = 0.4 + reformProgress * 0.4;
                    particle.scale.setScalar(1 + (1 - reformProgress) * 2);
                    
                    // Restore color
                    const originalColor = new THREE.Color(0xffa500);
                    particle.material.color.lerp(originalColor, reformProgress);
                    
                } else {
                    // Idle breathing animation
                    const breathe = Math.sin(time * 0.8 + index * 0.01) * 0.02;
                    particle.position.copy(particle.userData.originalPos);
                    particle.position.y += breathe;
                    
                    // Gentle color shifting
                    const hue = 0.08 + Math.sin(time * 0.5 + index * 0.1) * 0.02;
                    particle.material.color.setHSL(hue, 0.8, 0.6);
                    particle.material.opacity = 0.8;
                    particle.scale.setScalar(1);
                }
            });

            // Animate environmental particles
            particles.forEach(particle => {
                if (exploding && explosionProgress > 0.3) {
                    particle.userData.life += 0.02;
                    particle.material.opacity = Math.min(0.5, particle.userData.life) * (1 - (particle.userData.life / particle.userData.maxLife));
                    
                    particle.position.add(particle.userData.velocity);
                    particle.userData.velocity.multiplyScalar(0.98); // Friction
                    
                    if (particle.userData.life > particle.userData.maxLife) {
                        particle.userData.life = 0;
                        particle.material.opacity = 0;
                        particle.position.set(
                            (Math.random() - 0.5) * 50,
                            (Math.random() - 0.5) * 50,
                            (Math.random() - 0.5) * 50
                        );
                    }
                } else {
                    particle.material.opacity *= 0.95;
                }
            });

            // Camera movement
            camera.position.x = Math.sin(time * 0.1) * 3;
            camera.position.y = Math.cos(time * 0.08) * 2;
            camera.lookAt(0, 1, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('click', () => {
            if (!exploding && !reforming) {
                exploding = true;
                explosionProgress = 0;
            }
        });

        init();
    </script>
</body>
</html>