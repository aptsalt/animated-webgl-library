<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Human Figure Isometric - Mindful Journey</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #1a1a2e;
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid rgba(135, 206, 235, 0.4);
            color: #87ceeb;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .back-btn:hover {
            background: rgba(135, 206, 235, 0.1);
            border-color: rgba(135, 206, 235, 0.8);
        }
        
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(135, 206, 235, 0.8);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-btn">‚Üê Back</a>
    <div class="instruction">Click to populate isometric world</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let mainFigure;
        let smallFigures = [];
        let buildings = [];
        let time = 0;
        let populating = false;
        let populateProgress = 0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Isometric camera setup
            camera = new THREE.OrthographicCamera(
                window.innerWidth / -100, window.innerWidth / 100,
                window.innerHeight / 100, window.innerHeight / -100,
                1, 1000
            );
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x87ceeb, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            createMainFigure();
            createIsometricWorld();
            animate();
        }

        function createMainFigure() {
            const group = new THREE.Group();
            
            const material = new THREE.MeshLambertMaterial({
                color: 0x87ceeb,
                transparent: true,
                opacity: 0.9
            });
            
            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 6), material.clone());
            head.position.y = 3.5;
            head.castShadow = true;
            
            // Torso
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 0.8), material.clone());
            torso.position.y = 2;
            torso.castShadow = true;
            
            // Arms
            const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.5, 0.4), material.clone());
            leftArm.position.set(-0.8, 2.2, 0);
            leftArm.rotation.z = 0.2;
            leftArm.castShadow = true;
            
            const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.5, 0.4), material.clone());
            rightArm.position.set(0.8, 2.2, 0);
            rightArm.rotation.z = -0.2;
            rightArm.castShadow = true;
            
            // Legs
            const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2, 0.5), material.clone());
            leftLeg.position.set(-0.3, 0.5, 0);
            leftLeg.castShadow = true;
            
            const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2, 0.5), material.clone());
            rightLeg.position.set(0.3, 0.5, 0);
            rightLeg.castShadow = true;
            
            group.add(head, torso, leftArm, rightArm, leftLeg, rightLeg);
            scene.add(group);
            mainFigure = group;
        }

        function createIsometricWorld() {
            // Create ground plane
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d2d44,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Create buildings in grid pattern
            for (let x = -8; x <= 8; x += 4) {
                for (let z = -8; z <= 8; z += 4) {
                    if (x === 0 && z === 0) continue; // Skip center where main figure is
                    
                    const height = 2 + Math.random() * 6;
                    const building = new THREE.Mesh(
                        new THREE.BoxGeometry(2, height, 2),
                        new THREE.MeshLambertMaterial({
                            color: new THREE.Color().setHSL(0.6 + Math.random() * 0.2, 0.3, 0.4),
                            transparent: true,
                            opacity: 0
                        })
                    );
                    building.position.set(x, height / 2, z);
                    building.castShadow = true;
                    building.userData = { targetOpacity: 0.7, originalY: building.position.y };
                    scene.add(building);
                    buildings.push(building);
                }
            }

            // Create small figures that will populate the world
            for (let i = 0; i < 20; i++) {
                const figure = createSmallFigure();
                const angle = (i / 20) * Math.PI * 2;
                const radius = 15 + Math.random() * 10;
                
                figure.position.set(
                    Math.cos(angle) * radius,
                    0.5,
                    Math.sin(angle) * radius
                );
                figure.userData = {
                    angle: angle,
                    radius: radius,
                    speed: 0.01 + Math.random() * 0.02,
                    targetScale: 0.3 + Math.random() * 0.3,
                    currentScale: 0
                };
                scene.add(figure);
                smallFigures.push(figure);
            }
        }

        function createSmallFigure() {
            const group = new THREE.Group();
            const material = new THREE.MeshLambertMaterial({
                color: new THREE.Color().setHSL(0.5 + Math.random() * 0.3, 0.6, 0.7),
                transparent: true,
                opacity: 0
            });
            
            // Simplified small figure
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 6, 4), material.clone());
            head.position.y = 0.7;
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.15), material.clone());
            body.position.y = 0.3;
            
            group.add(head, body);
            group.scale.setScalar(0);
            return group;
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            if (populating) {
                populateProgress += 0.006;
                if (populateProgress >= 1) {
                    populateProgress = 1;
                    populating = false;
                }
            }

            // Animate main figure - gentle breathing and slight movements
            mainFigure.scale.y = 1 + Math.sin(time * 0.8) * 0.05;
            mainFigure.rotation.y = Math.sin(time * 0.3) * 0.1;

            // Animate buildings appearing
            buildings.forEach((building, index) => {
                const delay = (index / buildings.length) * 0.5;
                const progress = Math.max(0, Math.min(1, (populateProgress - delay) / 0.5));
                
                building.material.opacity = progress * building.userData.targetOpacity;
                building.position.y = building.userData.originalY * progress;
                building.scale.y = progress;
            });

            // Animate small figures
            smallFigures.forEach((figure, index) => {
                const userData = figure.userData;
                const delay = (index / smallFigures.length) * 0.8;
                const progress = Math.max(0, Math.min(1, (populateProgress - delay) / 0.2));
                
                // Scale in
                userData.currentScale = progress * userData.targetScale;
                figure.scale.setScalar(userData.currentScale);
                
                // Set opacity
                figure.children.forEach(child => {
                    child.material.opacity = progress * 0.8;
                });
                
                // Movement around main figure
                if (progress > 0) {
                    userData.angle += userData.speed;
                    figure.position.x = Math.cos(userData.angle) * userData.radius;
                    figure.position.z = Math.sin(userData.angle) * userData.radius;
                    
                    // Bobbing animation
                    figure.position.y = 0.5 + Math.sin(time * 2 + index) * 0.1;
                    
                    // Look towards center
                    figure.lookAt(0, figure.position.y, 0);
                }
            });

            // Isometric camera gentle movement
            const cameraRadius = 15;
            camera.position.x = Math.cos(time * 0.1) * cameraRadius;
            camera.position.z = Math.sin(time * 0.1) * cameraRadius;
            camera.position.y = 10 + Math.sin(time * 0.15) * 2;
            camera.lookAt(0, 2, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.left = window.innerWidth / -100;
            camera.right = window.innerWidth / 100;
            camera.top = window.innerHeight / 100;
            camera.bottom = window.innerHeight / -100;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('click', () => {
            if (!populating && populateProgress < 1) {
                populating = true;
            } else if (populateProgress >= 1) {
                // Reset
                populateProgress = 0;
                populating = false;
                
                // Reset buildings
                buildings.forEach(building => {
                    building.material.opacity = 0;
                    building.scale.y = 0;
                });
                
                // Reset small figures
                smallFigures.forEach((figure, index) => {
                    figure.scale.setScalar(0);
                    figure.children.forEach(child => {
                        child.material.opacity = 0;
                    });
                    figure.userData.angle = (index / smallFigures.length) * Math.PI * 2;
                });
            }
        });

        init();
    </script>
</body>
</html>