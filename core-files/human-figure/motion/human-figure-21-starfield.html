<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Human Figure Starfield - Mindful Journey</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0a 100%);
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .back-btn {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 1px;
            border-radius: 20px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .back-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.6);
        }
        
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
        }
        
        .controls {
            position: absolute;
            top: 40px;
            right: 40px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        
        .control-btn {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
            font-size: 12px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.6);
        }
        
        .performance-indicator {
            position: absolute;
            top: 100px;
            right: 40px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 10px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-btn">‚Üê Back</a>
    <div class="instruction">Click to transform into starfield</div>
    
    <div class="controls">
        <button class="control-btn" onclick="toggleQuality()">Quality: High</button>
        <button class="control-btn" onclick="resetScene()">Reset</button>
        <button class="control-btn" onclick="toggleNebula()">Nebula: Off</button>
    </div>
    
    <div class="performance-indicator">
        <div id="fps">FPS: --</div>
        <div id="transform-progress">Transform: 0%</div>
        <div id="star-count">Stars: 2000</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let humanFigure;
        let starParticles = [];
        let nebulaParticles = [];
        let cosmicDust = [];
        let time = 0;
        let transforming = false;
        let transformProgress = 0;
        let qualityLevel = 'high';
        let nebulaEffects = false;
        let performanceStats = { fps: 0, frameCount: 0, lastTime: 0 };
        let ambientLight, pointLights = [];
        let mousePosition = { x: 0, y: 0 };
        let cameraTarget = { x: 0, y: 0, z: 0 };
        let starfield, galaxySpiral;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            document.body.appendChild(renderer.domElement);
            
            // Cosmic lighting setup
            ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.2);
            scene.add(ambientLight);
            
            // Create multiple colored point lights for cosmic effect
            const lightColors = [0x4a9eff, 0xff6b4a, 0x4aff9e, 0xff4aff, 0xffff4a];
            lightColors.forEach((color, index) => {
                const light = new THREE.PointLight(color, 0.3, 30);
                const angle = (index / lightColors.length) * Math.PI * 2;
                light.position.set(
                    Math.cos(angle) * 15,
                    Math.sin(angle) * 10,
                    Math.sin(angle * 2) * 8
                );
                scene.add(light);
                pointLights.push(light);
            });

            createHumanFigure();
            createStarfield();
            createCosmicEnvironment();
            setupEventListeners();
            animate();
        }

        function createHumanFigure() {
            const group = new THREE.Group();
            
            // Enhanced cosmic material
            const materialConfig = qualityLevel === 'high' ? {
                color: 0xffffff,
                transparent: true,
                opacity: 0.95,
                emissive: 0x222244,
                emissiveIntensity: 0.2,
                side: THREE.DoubleSide
            } : {
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            };
            
            const MaterialClass = qualityLevel === 'high' ? THREE.MeshStandardMaterial : THREE.MeshBasicMaterial;
            const material = new MaterialClass(materialConfig);
            
            // Enhanced anatomical structure
            const detail = qualityLevel === 'high' ? { sphere: [20, 16], cylinder: 20 } : { sphere: [8, 6], cylinder: 8 };
            const bodyParts = [];
            
            // Head with ethereal glow
            const headGeometry = new THREE.SphereGeometry(0.32, detail.sphere[0], detail.sphere[1]);
            const head = new THREE.Mesh(headGeometry, material.clone());
            head.position.y = 2.6;
            head.scale.set(1, 1.1, 0.95);
            bodyParts.push({ mesh: head, originalPos: head.position.clone(), type: 'head' });
            
            // Neck
            const neckGeometry = new THREE.CylinderGeometry(0.14, 0.16, 0.25, detail.cylinder);
            const neck = new THREE.Mesh(neckGeometry, material.clone());
            neck.position.y = 2.2;
            bodyParts.push({ mesh: neck, originalPos: neck.position.clone(), type: 'neck' });
            
            // Upper torso with cosmic aura
            const upperTorsoGeometry = new THREE.CylinderGeometry(0.35, 0.3, 0.8, detail.cylinder);
            const upperTorso = new THREE.Mesh(upperTorsoGeometry, material.clone());
            upperTorso.position.y = 1.6;
            upperTorso.scale.set(1.15, 1, 0.9);
            bodyParts.push({ mesh: upperTorso, originalPos: upperTorso.position.clone(), type: 'torso' });
            
            // Lower torso
            const lowerTorsoGeometry = new THREE.CylinderGeometry(0.3, 0.35, 0.7, detail.cylinder);
            const lowerTorso = new THREE.Mesh(lowerTorsoGeometry, material.clone());
            lowerTorso.position.y = 0.9;
            bodyParts.push({ mesh: lowerTorso, originalPos: lowerTorso.position.clone(), type: 'torso' });
            
            // Shoulders with stellar connection
            const shoulderGeometry = new THREE.SphereGeometry(0.16, detail.cylinder, detail.cylinder);
            const leftShoulder = new THREE.Mesh(shoulderGeometry, material.clone());
            leftShoulder.position.set(-0.45, 1.9, 0);
            bodyParts.push({ mesh: leftShoulder, originalPos: leftShoulder.position.clone(), type: 'shoulder' });
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, material.clone());
            rightShoulder.position.set(0.45, 1.9, 0);
            bodyParts.push({ mesh: rightShoulder, originalPos: rightShoulder.position.clone(), type: 'shoulder' });
            
            // Arms reaching toward cosmos
            const upperArmGeometry = new THREE.CylinderGeometry(0.12, 0.14, 0.7, detail.cylinder);
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, material.clone());
            leftUpperArm.position.set(-0.6, 1.4, 0);
            leftUpperArm.rotation.z = 0.4;
            bodyParts.push({ mesh: leftUpperArm, originalPos: leftUpperArm.position.clone(), type: 'arm' });
            
            const rightUpperArm = new THREE.Mesh(upperArmGeometry, material.clone());
            rightUpperArm.position.set(0.6, 1.4, 0);
            rightUpperArm.rotation.z = -0.4;
            bodyParts.push({ mesh: rightUpperArm, originalPos: rightUpperArm.position.clone(), type: 'arm' });
            
            // Forearms
            const forearmGeometry = new THREE.CylinderGeometry(0.09, 0.11, 0.6, detail.cylinder);
            const leftForearm = new THREE.Mesh(forearmGeometry, material.clone());
            leftForearm.position.set(-0.75, 0.9, 0);
            leftForearm.rotation.z = 0.2;
            bodyParts.push({ mesh: leftForearm, originalPos: leftForearm.position.clone(), type: 'arm' });
            
            const rightForearm = new THREE.Mesh(forearmGeometry, material.clone());
            rightForearm.position.set(0.75, 0.9, 0);
            rightForearm.rotation.z = -0.2;
            bodyParts.push({ mesh: rightForearm, originalPos: rightForearm.position.clone(), type: 'arm' });
            
            // Hands reaching for stars
            const handGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.06);
            const leftHand = new THREE.Mesh(handGeometry, material.clone());
            leftHand.position.set(-0.82, 0.5, 0);
            bodyParts.push({ mesh: leftHand, originalPos: leftHand.position.clone(), type: 'hand' });
            
            const rightHand = new THREE.Mesh(handGeometry, material.clone());
            rightHand.position.set(0.82, 0.5, 0);
            bodyParts.push({ mesh: rightHand, originalPos: rightHand.position.clone(), type: 'hand' });
            
            // Thighs
            const thighGeometry = new THREE.CylinderGeometry(0.15, 0.18, 0.8, detail.cylinder);
            const leftThigh = new THREE.Mesh(thighGeometry, material.clone());
            leftThigh.position.set(-0.12, 0.1, 0);
            bodyParts.push({ mesh: leftThigh, originalPos: leftThigh.position.clone(), type: 'leg' });
            
            const rightThigh = new THREE.Mesh(thighGeometry, material.clone());
            rightThigh.position.set(0.12, 0.1, 0);
            bodyParts.push({ mesh: rightThigh, originalPos: rightThigh.position.clone(), type: 'leg' });
            
            // Calves
            const calfGeometry = new THREE.CylinderGeometry(0.1, 0.13, 0.7, detail.cylinder);
            const leftCalf = new THREE.Mesh(calfGeometry, material.clone());
            leftCalf.position.set(-0.12, -0.5, 0);
            bodyParts.push({ mesh: leftCalf, originalPos: leftCalf.position.clone(), type: 'leg' });
            
            const rightCalf = new THREE.Mesh(calfGeometry, material.clone());
            rightCalf.position.set(0.12, -0.5, 0);
            bodyParts.push({ mesh: rightCalf, originalPos: rightCalf.position.clone(), type: 'leg' });
            
            bodyParts.forEach(part => {
                group.add(part.mesh);
            });
            
            group.userData.bodyParts = bodyParts;
            scene.add(group);
            humanFigure = group;
        }
        
        function createStarfield() {
            starfield = new THREE.Group();
            
            const starCount = qualityLevel === 'high' ? 3000 : 2000;
            document.getElementById('star-count').textContent = `Stars: ${starCount}`;
            
            // Create multiple layers of stars for depth
            const starLayers = [
                { count: Math.floor(starCount * 0.1), size: [0.05, 0.08], distance: 80, brightness: 1.0 },
                { count: Math.floor(starCount * 0.2), size: [0.03, 0.06], distance: 120, brightness: 0.8 },
                { count: Math.floor(starCount * 0.3), size: [0.02, 0.04], distance: 180, brightness: 0.6 },
                { count: Math.floor(starCount * 0.4), size: [0.01, 0.03], distance: 250, brightness: 0.4 }
            ];
            
            starLayers.forEach((layer, layerIndex) => {
                for (let i = 0; i < layer.count; i++) {
                    const size = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
                    const geometry = new THREE.SphereGeometry(size, 6, 4);
                    
                    // Varied star colors
                    const starType = Math.random();
                    let color;
                    if (starType < 0.3) color = 0x8bb8ff; // Blue giant
                    else if (starType < 0.6) color = 0xffffff; // White dwarf
                    else if (starType < 0.8) color = 0xffdd88; // Yellow star
                    else color = 0xff8844; // Red giant
                    
                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: layer.brightness * (0.5 + Math.random() * 0.5)
                    });
                    
                    const star = new THREE.Mesh(geometry, material);
                    
                    // Spherical distribution
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = 2 * Math.PI * Math.random();
                    const radius = layer.distance + (Math.random() - 0.5) * 40;
                    
                    star.position.set(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    );
                    
                    star.userData = {
                        originalPosition: star.position.clone(),
                        twinklePhase: Math.random() * Math.PI * 2,
                        twinkleSpeed: 0.5 + Math.random() * 1.5,
                        layer: layerIndex,
                        targetOpacity: material.opacity,
                        pullStrength: 0
                    };
                    
                    starfield.add(star);
                    starParticles.push(star);
                }
            });
            
            scene.add(starfield);
        }
        
        function createCosmicEnvironment() {
            // Create nebula particles
            const nebulaCount = qualityLevel === 'high' ? 500 : 300;
            for (let i = 0; i < nebulaCount; i++) {
                const geometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.8, 6, 4);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(
                        0.6 + Math.random() * 0.3,
                        0.7,
                        0.3 + Math.random() * 0.4
                    ),
                    transparent: true,
                    opacity: 0
                });
                
                const nebula = new THREE.Mesh(geometry, material);
                nebula.position.set(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );
                
                nebula.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02
                    ),
                    targetOpacity: 0.1 + Math.random() * 0.2,
                    baseOpacity: material.opacity
                };
                
                scene.add(nebula);
                nebulaParticles.push(nebula);
            }
            
            // Create cosmic dust
            const dustCount = qualityLevel === 'high' ? 800 : 400;
            for (let i = 0; i < dustCount; i++) {
                const geometry = new THREE.SphereGeometry(0.005 + Math.random() * 0.01, 3, 2);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(
                        0.05 + Math.random() * 0.1,
                        0.3,
                        0.6 + Math.random() * 0.3
                    ),
                    transparent: true,
                    opacity: 0
                });
                
                const dust = new THREE.Mesh(geometry, material);
                dust.position.set(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
                
                dust.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.005,
                        (Math.random() - 0.5) * 0.005,
                        (Math.random() - 0.5) * 0.005
                    ),
                    life: Math.random() * 10
                };
                
                scene.add(dust);
                cosmicDust.push(dust);
            }
            
            // Create galaxy spiral
            createGalaxySpiral();
        }
        
        function createGalaxySpiral() {
            galaxySpiral = new THREE.Group();
            
            const arms = 3;
            const pointsPerArm = qualityLevel === 'high' ? 200 : 100;
            
            for (let arm = 0; arm < arms; arm++) {
                for (let i = 0; i < pointsPerArm; i++) {
                    const t = i / pointsPerArm;
                    const angle = arm * (2 * Math.PI / arms) + t * Math.PI * 4;
                    const radius = 30 + t * 100;
                    
                    const geometry = new THREE.SphereGeometry(0.02 + Math.random() * 0.03, 4, 3);
                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(
                            0.6 + Math.random() * 0.2,
                            0.8,
                            0.4 + Math.random() * 0.4
                        ),
                        transparent: true,
                        opacity: 0
                    });
                    
                    const point = new THREE.Mesh(geometry, material);
                    point.position.set(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 20,
                        Math.sin(angle) * radius
                    );
                    
                    point.userData = {
                        angle: angle,
                        radius: radius,
                        originalY: point.position.y,
                        targetOpacity: 0.3 + Math.random() * 0.4
                    };
                    
                    galaxySpiral.add(point);
                }
            }
            
            galaxySpiral.rotation.x = Math.PI / 6;
            scene.add(galaxySpiral);
        }


        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Performance tracking
            updatePerformanceStats();

            if (transforming) {
                transformProgress += 0.005;
                if (transformProgress >= 1) {
                    transformProgress = 1;
                }
            }
            
            // Update all systems
            updateFigureTransformation();
            updateStarfield();
            updateCosmicEnvironment();
            updateLighting();
            updateCamera();

            renderer.render(scene, camera);
        }
        
        function updateFigureTransformation() {
            // Enhanced transformation with multiple phases
            const phases = {
                dissolving: transformProgress < 0.3,
                dispersing: transformProgress >= 0.3 && transformProgress < 0.7,
                cosmic: transformProgress >= 0.7
            };
            
            const easeProgress = 1 - Math.pow(1 - transformProgress, 2);
            
            humanFigure.userData.bodyParts.forEach((part, index) => {
                if (phases.dissolving) {
                    // Initial dissolution with shimmering
                    const shimmer = Math.sin(time * 5 + index) * 0.1;
                    part.mesh.material.opacity = (0.95 - transformProgress * 1.2) + shimmer;
                    
                    // Slight expansion
                    const expansion = 1 + transformProgress * 0.1;
                    part.mesh.scale.set(expansion, expansion, expansion);
                    
                    // Color shift to cosmic blue
                    const blueShift = transformProgress * 0.5;
                    part.mesh.material.color.setRGB(
                        1 - blueShift,
                        1 - blueShift * 0.5,
                        1
                    );
                }
                
                if (phases.dispersing) {
                    // Body parts scatter toward stars
                    const scatterProgress = (transformProgress - 0.3) / 0.4;
                    const explosionForce = scatterProgress * 25;
                    
                    // Direction influenced by body part type
                    let direction = part.originalPos.clone().normalize();
                    if (part.type === 'hand') {
                        direction.multiplyScalar(explosionForce * 1.5); // Hands reach furthest
                    } else if (part.type === 'head') {
                        direction.y += 0.5; // Head rises upward
                        direction.multiplyScalar(explosionForce * 1.2);
                    } else {
                        direction.multiplyScalar(explosionForce);
                    }
                    
                    part.mesh.position.copy(part.originalPos).add(direction);
                    
                    // Rotation with cosmic energy
                    part.mesh.rotation.x = scatterProgress * Math.PI * 2;
                    part.mesh.rotation.y = scatterProgress * Math.PI * 1.5;
                    part.mesh.rotation.z = scatterProgress * Math.PI;
                    
                    // Fade to cosmic energy
                    part.mesh.material.opacity = 0.3 * (1 - scatterProgress);
                }
                
                if (phases.cosmic) {
                    // Final transformation into stardust
                    const cosmicProgress = (transformProgress - 0.7) / 0.3;
                    part.mesh.material.opacity = 0.1 * (1 - cosmicProgress);
                    
                    // Becomes part of the cosmos
                    part.mesh.scale.set(0.1, 0.1, 0.1);
                    
                    // Emit particles
                    if (Math.random() < 0.1) {
                        createStardustParticle(part.mesh.position);
                    }
                }
                
                // Add some individual variation
                const variation = Math.sin(time + index * 0.5) * 0.02;
                part.mesh.position.x += variation;
                part.mesh.position.y += Math.cos(time * 0.8 + index * 0.3) * 0.02;
            });
        }
        
        function createStardustParticle(position) {
            const geometry = new THREE.SphereGeometry(0.005, 3, 2);
            const material = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(
                    0.5 + Math.random() * 0.3,
                    0.8,
                    0.8
                ),
                transparent: true,
                opacity: 0.8
            });
            
            const particle = new THREE.Mesh(geometry, material);
            particle.position.copy(position);
            
            particle.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                ),
                life: 0,
                maxLife: 5
            };
            
            scene.add(particle);
            cosmicDust.push(particle);
        }
        
        function updateStarfield() {
            starParticles.forEach((star, index) => {
                // Twinkling effect
                const twinkle = Math.sin(time * star.userData.twinkleSpeed + star.userData.twinklePhase) * 0.3 + 0.7;
                star.material.opacity = star.userData.targetOpacity * twinkle;
                
                // Gravitational pull toward dissolving figure
                if (transformProgress > 0.2) {
                    const distanceToFigure = star.position.distanceTo(humanFigure.position);
                    const pullForce = Math.max(0, (100 - distanceToFigure) / 100) * transformProgress;
                    
                    star.userData.pullStrength = Math.min(1, star.userData.pullStrength + pullForce * 0.01);
                    
                    const direction = new THREE.Vector3()
                        .subVectors(humanFigure.position, star.position)
                        .normalize()
                        .multiplyScalar(star.userData.pullStrength * 0.05);
                    
                    star.position.add(direction);
                }
                
                // Enhanced brightness for transformation
                if (transformProgress > 0.5) {
                    const brightness = 1 + transformProgress;
                    star.material.opacity *= brightness;
                }
                
                // Slow rotation of entire starfield
                starfield.rotation.y += 0.0001;
                starfield.rotation.x += 0.00005;
            });
        }
        
        function updateCosmicEnvironment() {
            // Nebula effects
            if (nebulaEffects || transformProgress > 0.4) {
                nebulaParticles.forEach((nebula, index) => {
                    nebula.position.add(nebula.userData.velocity);
                    
                    // Fade in during transformation
                    const targetOpacity = transformProgress * nebula.userData.targetOpacity;
                    nebula.material.opacity += (targetOpacity - nebula.material.opacity) * 0.02;
                    
                    // Gentle pulsing
                    const pulse = Math.sin(time * 0.5 + index * 0.1) * 0.1 + 0.9;
                    nebula.scale.set(pulse, pulse, pulse);
                    
                    // Color shifting
                    const hue = (0.6 + time * 0.01 + index * 0.1) % 1;
                    nebula.material.color.setHSL(hue, 0.7, 0.4);
                });
            }
            
            // Cosmic dust
            cosmicDust.forEach((dust, index) => {
                dust.userData.life += 0.02;
                
                if (dust.userData.life > dust.userData.maxLife) {
                    scene.remove(dust);
                    cosmicDust.splice(index, 1);
                    return;
                }
                
                dust.position.add(dust.userData.velocity);
                
                // Fade out over lifetime
                const lifeRatio = dust.userData.life / dust.userData.maxLife;
                dust.material.opacity = 0.8 * (1 - lifeRatio);
                
                // Drift motion
                dust.position.x += Math.sin(time + index) * 0.001;
                dust.position.y += Math.cos(time * 0.8 + index) * 0.001;
            });
            
            // Galaxy spiral rotation
            if (galaxySpiral) {
                galaxySpiral.rotation.z += 0.001;
                
                galaxySpiral.children.forEach((point, index) => {
                    const targetOpacity = transformProgress * point.userData.targetOpacity;
                    point.material.opacity += (targetOpacity - point.material.opacity) * 0.01;
                    
                    // Spiral animation
                    point.userData.angle += 0.002;
                    point.position.x = Math.cos(point.userData.angle) * point.userData.radius;
                    point.position.z = Math.sin(point.userData.angle) * point.userData.radius;
                    point.position.y = point.userData.originalY + Math.sin(time + index * 0.1) * 2;
                });
            }
        }
        
        function updateLighting() {
            // Dynamic cosmic lighting
            pointLights.forEach((light, index) => {
                const angle = time * 0.1 + index * (Math.PI * 2 / pointLights.length);
                light.position.x = Math.cos(angle) * 15;
                light.position.z = Math.sin(angle) * 15;
                light.position.y = Math.sin(angle * 2) * 10;
                
                // Intensity pulses with transformation
                light.intensity = 0.3 + transformProgress * 0.5 + Math.sin(time * 2 + index) * 0.1;
            });
            
            // Ambient light increases with cosmic transformation
            ambientLight.intensity = 0.2 + transformProgress * 0.3;
        }
        
        function updateCamera() {
            // Mouse influence
            const mouseInfluence = 0.002;
            cameraTarget.x += (mousePosition.x * mouseInfluence - cameraTarget.x) * 0.05;
            cameraTarget.y += (mousePosition.y * mouseInfluence - cameraTarget.y) * 0.05;
            
            // Cinematic camera movement during transformation
            if (transforming) {
                const cinematicRadius = 15 + transformProgress * 10;
                const height = transformProgress * 5;
                
                camera.position.x = Math.sin(time * 0.1) * cinematicRadius + cameraTarget.x;
                camera.position.y = Math.cos(time * 0.08) * 3 + height;
                camera.position.z = Math.cos(time * 0.1) * cinematicRadius;
            } else {
                // Gentle floating when static
                camera.position.x = Math.sin(time * 0.05) * 2 + cameraTarget.x;
                camera.position.y = Math.cos(time * 0.03) * 1.5 + cameraTarget.y;
                camera.position.z = 15 + Math.sin(time * 0.02) * 2;
            }
            
            camera.lookAt(0, 0, 0);
        }
        
        function updatePerformanceStats() {
            performanceStats.frameCount++;
            const currentTime = performance.now();
            
            if (currentTime - performanceStats.lastTime >= 1000) {
                performanceStats.fps = performanceStats.frameCount;
                performanceStats.frameCount = 0;
                performanceStats.lastTime = currentTime;
                
                document.getElementById('fps').textContent = `FPS: ${performanceStats.fps}`;
                document.getElementById('transform-progress').textContent = `Transform: ${Math.round(transformProgress * 100)}%`;
            }
        }

        function setupEventListeners() {
            // Mouse tracking
            window.addEventListener('mousemove', (event) => {
                mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
                mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
            });
            
            // Touch support
            window.addEventListener('touchmove', (event) => {
                if (event.touches.length > 0) {
                    const touch = event.touches[0];
                    mousePosition.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mousePosition.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                }
                event.preventDefault();
            });
            
            // Resize handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Click/tap handler
            window.addEventListener('click', handleSceneClick);
            window.addEventListener('touchstart', handleSceneClick);
            
            // Keyboard controls
            window.addEventListener('keydown', (event) => {
                switch(event.key) {
                    case ' ':
                        event.preventDefault();
                        handleSceneClick();
                        break;
                    case 'r':
                    case 'R':
                        resetScene();
                        break;
                    case 'n':
                    case 'N':
                        toggleNebula();
                        break;
                }
            });
        }
        
        function handleSceneClick() {
            if (!transforming && transformProgress < 1) {
                transforming = true;
            } else if (transformProgress >= 1) {
                resetScene();
            }
        }
        
        function resetScene() {
            transformProgress = 0;
            transforming = false;
            
            // Reset human figure
            humanFigure.userData.bodyParts.forEach(part => {
                part.mesh.position.copy(part.originalPos);
                part.mesh.material.opacity = 0.95;
                part.mesh.rotation.set(0, 0, 0);
                part.mesh.scale.set(1, 1, 1);
                part.mesh.material.color.setRGB(1, 1, 1);
            });
            
            // Reset starfield
            starParticles.forEach(star => {
                star.position.copy(star.userData.originalPosition);
                star.userData.pullStrength = 0;
                star.material.opacity = star.userData.targetOpacity;
            });
            
            // Reset nebula particles
            nebulaParticles.forEach(nebula => {
                nebula.material.opacity = 0;
            });
            
            // Clear cosmic dust
            cosmicDust.forEach(dust => scene.remove(dust));
            cosmicDust.length = 0;
            
            // Reset galaxy spiral
            if (galaxySpiral) {
                galaxySpiral.children.forEach(point => {
                    point.material.opacity = 0;
                });
            }
            
            // Reset lighting
            pointLights.forEach(light => {
                light.intensity = 0.3;
            });
            ambientLight.intensity = 0.2;
            
            // Reset camera
            camera.position.set(0, 0, 15);
            cameraTarget = { x: 0, y: 0, z: 0 };
        }
        
        function toggleQuality() {
            qualityLevel = qualityLevel === 'high' ? 'medium' : 'high';
            document.querySelector('.control-btn').textContent = `Quality: ${qualityLevel.charAt(0).toUpperCase() + qualityLevel.slice(1)}`;
            
            // Recreate scene with new quality
            scene.remove(humanFigure);
            scene.remove(starfield);
            scene.remove(galaxySpiral);
            
            starParticles.forEach(star => scene.remove(star));
            nebulaParticles.forEach(nebula => scene.remove(nebula));
            cosmicDust.forEach(dust => scene.remove(dust));
            
            starParticles.length = 0;
            nebulaParticles.length = 0;
            cosmicDust.length = 0;
            
            createHumanFigure();
            createStarfield();
            createCosmicEnvironment();
        }
        
        function toggleNebula() {
            nebulaEffects = !nebulaEffects;
            document.querySelector('.control-btn:nth-child(3)').textContent = `Nebula: ${nebulaEffects ? 'On' : 'Off'}`;
        }

        init();
        
        // Performance optimization
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (performanceStats.fps < 30) {
                    qualityLevel = 'medium';
                    toggleQuality();
                }
            }, 2000);
        });
    </script>
</body>
</html>