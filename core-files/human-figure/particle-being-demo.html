<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Being Library Demo</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #f8f8f6; /* Toned white default */
            font-family: 'Inter', system-ui, sans-serif;
        }
        canvas { display: block; }
        
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            color: #333;
            width: 220px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 5px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #333;
            border-radius: 5px;
        }
        
        span {
            color: #555;
            font-weight: bold;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #333;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: rgba(0, 0, 0, 0.2);
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(0, 0, 0, 0.6);
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Particle Being Controls</h3>
        
        <div class="control-group">
            <label>Body Type</label>
            <select id="bodyType">
                <option value="child">Child</option>
                <option value="teen">Teenager</option>
                <option value="adult" selected>Adult</option>
                <option value="elderly">Elderly</option>
                <option value="athletic">Athletic</option>
                <option value="pregnant">Pregnant</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Particle Count</label>
            <input type="range" id="particleCount" min="100" max="500" value="250">
            <span id="particleCountDisplay">250</span>
        </div>
        
        <div class="control-group">
            <label>Speed Multiplier</label>
            <input type="range" id="speedMultiplier" min="0.1" max="2" step="0.1" value="1">
            <span id="speedDisplay">1.0</span>
        </div>
        
        <div class="control-group">
            <label>Figure Color</label>
            <select id="figureColor">
                <option value="light-charcoal" selected>Light Charcoal</option>
                <option value="white">White</option>
                <option value="warm-gray">Warm Gray</option>
                <option value="cool-gray">Cool Gray</option>
                <option value="warm">Warm Tones</option>
                <option value="cool">Cool Tones</option>
                <option value="rainbow">Rainbow</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Background Color</label>
            <select id="backgroundColor">
                <option value="toned-white" selected>Toned White</option>
                <option value="pure-white">Pure White</option>
                <option value="light-gray">Light Gray</option>
                <option value="dark-blue">Dark Blue</option>
                <option value="charcoal">Charcoal</option>
                <option value="black">Black</option>
                <option value="gradient-purple">Purple Gradient</option>
                <option value="gradient-blue">Blue Gradient</option>
            </select>
        </div>
        
        <div class="control-group">
            <button onclick="createNewBeing()">Create New Being</button>
            <button onclick="clearAll()">Clear All</button>
            <button onclick="updateColors()">Update Colors</button>
        </div>
    </div>
    
    <div class="info">
        Move mouse to influence particles
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Embedded Particle Being System
        class ParticleBeingSystem {
            constructor(scene, options = {}) {
                this.scene = scene;
                this.beings = [];
                this.ambientParticles = [];
                this.time = 0;
                
                this.options = {
                    particleCount: 200,
                    particleSize: 0.08,
                    ambientParticleCount: 100,
                    speedMultiplier: 1.0,
                    colorRange: { h: 0, s: 0, lMin: 0.25, lMax: 0.35 }, // Light charcoal default
                    states: ['forming', 'stable', 'dissolving', 'scattered'],
                    stateTimings: {
                        forming: 4,
                        stable: 3,
                        dissolving: 3,
                        scattered: 2
                    },
                    attractionForces: {
                        forming: 0.04,
                        stable: 0.024,
                        dissolving: 0.008,
                        scattered: 0.004
                    },
                    turbulenceStrength: 0.008,
                    oscillationSpeed: 0.016,
                    ...options
                };
            }

            convertToParticleBeing(mesh, position = { x: 0, y: 0, z: 0 }, customOptions = {}) {
                const beingOptions = { ...this.options, ...customOptions };
                const being = {
                    particles: [],
                    userData: {
                        index: this.beings.length,
                        transformationPhase: Math.random() * Math.PI * 2,
                        transformationSpeed: (0.3 + Math.random() * 0.2) * beingOptions.speedMultiplier,
                        state: 'forming',
                        stateTimer: 0,
                        basePosition: new THREE.Vector3(position.x, position.y, position.z),
                        originalMesh: mesh,
                        options: beingOptions
                    }
                };

                const points = this.extractPointsFromMesh(mesh, beingOptions.particleCount);
                
                points.forEach((point, i) => {
                    const particle = this.createParticle(point, position, beingOptions);
                    particle.userData.beingIndex = this.beings.length;
                    particle.userData.particleIndex = i;
                    
                    this.scene.add(particle);
                    being.particles.push(particle);
                });

                if (mesh) {
                    mesh.visible = false;
                }

                this.beings.push(being);
                return being;
            }

            extractPointsFromMesh(mesh, targetCount) {
                const points = [];
                
                if (!mesh || !mesh.geometry) {
                    return this.generateHumanSilhouettePoints(targetCount);
                }

                const geometry = mesh.geometry;
                
                if (geometry.isBufferGeometry) {
                    const positions = geometry.attributes.position;
                    const step = Math.max(1, Math.floor(positions.count / targetCount));
                    
                    for (let i = 0; i < positions.count && points.length < targetCount; i += step) {
                        points.push(new THREE.Vector3(
                            positions.getX(i),
                            positions.getY(i),
                            positions.getZ(i)
                        ));
                    }
                }
                
                while (points.length < targetCount && points.length > 0) {
                    const idx1 = Math.floor(Math.random() * points.length);
                    const idx2 = Math.floor(Math.random() * points.length);
                    const interpolated = new THREE.Vector3().lerpVectors(
                        points[idx1],
                        points[idx2],
                        Math.random()
                    );
                    points.push(interpolated);
                }
                
                return points.length > 0 ? points : this.generateHumanSilhouettePoints(targetCount);
            }

            generateHumanSilhouettePoints(count, bodyType = 'adult') {
                const points = [];
                const variations = {
                    child: { height: 0.6, width: 0.7, headSize: 1.2 },
                    teen: { height: 0.85, width: 0.85, headSize: 1.0 },
                    adult: { height: 1.0, width: 1.0, headSize: 1.0 },
                    elderly: { height: 0.95, width: 1.0, headSize: 1.0 },
                    athletic: { height: 1.05, width: 1.1, headSize: 0.95 },
                    pregnant: { height: 1.0, width: 1.3, headSize: 1.0 }
                };
                
                const config = variations[bodyType] || variations.adult;
                
                // Head
                const headCount = Math.floor(count * 0.15);
                for (let i = 0; i < headCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = 0.7 * config.headSize;
                    
                    points.push(new THREE.Vector3(
                        radius * Math.sin(phi) * Math.cos(theta) * config.width,
                        (3.5 + radius * Math.cos(phi)) * config.height,
                        radius * Math.sin(phi) * Math.sin(theta)
                    ));
                }
                
                // Torso
                const torsoCount = Math.floor(count * 0.35);
                for (let i = 0; i < torsoCount; i++) {
                    const y = 1 + Math.random() * 2;
                    const radius = (0.4 + (2 - y) * 0.2) * config.width;
                    const angle = Math.random() * Math.PI * 2;
                    
                    points.push(new THREE.Vector3(
                        radius * Math.cos(angle),
                        y * config.height,
                        radius * Math.sin(angle)
                    ));
                }
                
                // Arms
                const armCount = Math.floor(count * 0.25);
                for (let arm = 0; arm < 2; arm++) {
                    const side = arm === 0 ? -1 : 1;
                    for (let i = 0; i < armCount / 2; i++) {
                        const t = i / (armCount / 2 - 1);
                        const armLength = 2.5 * config.height;
                        const x = side * (0.8 + t * armLength * Math.cos(0.3)) * config.width;
                        const y = (2.5 - t * armLength * Math.sin(0.3)) * config.height;
                        const z = (Math.random() - 0.5) * 0.3;
                        
                        points.push(new THREE.Vector3(x, y, z));
                    }
                }
                
                // Legs
                const legCount = count - points.length;
                for (let leg = 0; leg < 2; leg++) {
                    const side = leg === 0 ? -0.3 : 0.3;
                    for (let i = 0; i < legCount / 2; i++) {
                        const t = i / (legCount / 2 - 1);
                        const legLength = 2.8 * config.height;
                        const x = (side + (Math.random() - 0.5) * 0.2) * config.width;
                        const y = (1 - t * legLength) * config.height;
                        const z = (Math.random() - 0.5) * 0.3;
                        
                        points.push(new THREE.Vector3(x, y, z));
                    }
                }
                
                return points;
            }

            createParticle(targetPoint, basePosition, options) {
                const particleGeometry = new THREE.SphereGeometry(options.particleSize, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(
                        options.colorRange.h,
                        options.colorRange.s,
                        options.colorRange.lMin + Math.random() * (options.colorRange.lMax - options.colorRange.lMin)
                    ),
                    transparent: true,
                    opacity: 0.7 + Math.random() * 0.3
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                const scatteredPos = new THREE.Vector3(
                    basePosition.x + (Math.random() - 0.5) * 20,
                    Math.random() * 15,
                    basePosition.z + (Math.random() - 0.5) * 20
                );
                particle.position.copy(scatteredPos);
                
                const targetPos = new THREE.Vector3(
                    basePosition.x + targetPoint.x,
                    basePosition.y + targetPoint.y + 2,
                    basePosition.z + targetPoint.z
                );
                
                particle.userData = {
                    targetPosition: targetPos,
                    scatteredPosition: scatteredPos.clone(),
                    velocity: new THREE.Vector3(0, 0, 0),
                    originalOpacity: particle.material.opacity,
                    oscillationPhase: Math.random() * Math.PI * 2
                };
                
                return particle;
            }

            createAmbientParticles(count = null) {
                const particleCount = count || this.options.ambientParticleCount;
                
                for (let i = 0; i < particleCount; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0x666666,
                        transparent: true,
                        opacity: 0.1 + Math.random() * 0.2
                    });
                    
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.set(
                        (Math.random() - 0.5) * 60,
                        Math.random() * 20,
                        (Math.random() - 0.5) * 60
                    );
                    
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.08,
                            (Math.random() - 0.5) * 0.04,
                            (Math.random() - 0.5) * 0.08
                        ),
                        drift: new THREE.Vector3(
                            Math.sin(Math.random() * Math.PI * 2) * 0.008,
                            Math.cos(Math.random() * Math.PI * 2) * 0.004,
                            Math.sin(Math.random() * Math.PI * 2) * 0.008
                        )
                    };
                    
                    this.scene.add(particle);
                    this.ambientParticles.push(particle);
                }
            }

            updateBeing(being, deltaTime) {
                const userData = being.userData;
                const options = userData.options;
                
                userData.transformationPhase += userData.transformationSpeed * deltaTime;
                userData.stateTimer += deltaTime;
                
                const currentStateTiming = options.stateTimings[userData.state];
                if (userData.stateTimer > currentStateTiming + Math.random() * 2) {
                    const states = options.states;
                    const currentIndex = states.indexOf(userData.state);
                    userData.state = states[(currentIndex + 1) % states.length];
                    userData.stateTimer = 0;
                }
                
                being.particles.forEach((particle, index) => {
                    this.updateParticle(particle, userData, deltaTime);
                });
            }

            updateParticle(particle, beingData, deltaTime) {
                const particleData = particle.userData;
                const options = beingData.options;
                let targetPos;
                let targetOpacity;
                let attractionForce = options.attractionForces[beingData.state] || 0.02;
                
                switch (beingData.state) {
                    case 'forming':
                        targetPos = particleData.targetPosition.clone();
                        targetOpacity = particleData.originalOpacity;
                        break;
                        
                    case 'stable':
                        targetPos = particleData.targetPosition.clone();
                        const breathe = Math.sin(beingData.transformationPhase * 2) * 0.1;
                        targetPos.multiplyScalar(1 + breathe);
                        targetPos.add(beingData.basePosition);
                        targetOpacity = particleData.originalOpacity;
                        break;
                        
                    case 'dissolving':
                        const dissolveProgress = beingData.stateTimer / options.stateTimings.dissolving;
                        targetPos = new THREE.Vector3().lerpVectors(
                            particleData.targetPosition,
                            particleData.scatteredPosition,
                            dissolveProgress
                        );
                        targetOpacity = particleData.originalOpacity * (1 - dissolveProgress);
                        break;
                        
                    case 'scattered':
                        targetPos = particleData.scatteredPosition.clone();
                        targetPos.add(new THREE.Vector3(
                            Math.sin(beingData.transformationPhase + particleData.particleIndex) * 5,
                            Math.cos(beingData.transformationPhase * 0.5 + particleData.particleIndex) * 3,
                            Math.sin(beingData.transformationPhase * 0.7 + particleData.particleIndex) * 5
                        ));
                        targetOpacity = particleData.originalOpacity * 0.3;
                        break;
                        
                    default:
                        targetPos = particleData.targetPosition.clone();
                        targetOpacity = particleData.originalOpacity;
                }
                
                const direction = targetPos.clone().sub(particle.position);
                const distance = direction.length();
                
                if (distance > 0.1) {
                    direction.normalize().multiplyScalar(attractionForce * Math.min(distance, 5));
                    particleData.velocity.add(direction);
                }
                
                const turbulence = new THREE.Vector3(
                    Math.sin(this.time * 2.4 + particleData.particleIndex * 0.1) * options.turbulenceStrength,
                    Math.cos(this.time * 1.6 + particleData.particleIndex * 0.15) * options.turbulenceStrength,
                    Math.sin(this.time * 2 + particleData.particleIndex * 0.12) * options.turbulenceStrength
                );
                particleData.velocity.add(turbulence);
                
                particleData.velocity.multiplyScalar(0.95);
                particle.position.add(particleData.velocity);
                particle.material.opacity += (targetOpacity - particle.material.opacity) * 0.05;
                
                particleData.oscillationPhase += options.oscillationSpeed;
                const oscillation = Math.sin(particleData.oscillationPhase) * 0.05;
                particle.position.y += oscillation;
                
                const maxDistance = 25;
                const distanceFromBase = particle.position.distanceTo(beingData.basePosition);
                if (distanceFromBase > maxDistance) {
                    const pullBack = beingData.basePosition.clone().sub(particle.position).normalize();
                    particleData.velocity.add(pullBack.multiplyScalar(0.01));
                }
            }

            updateAmbientParticles(deltaTime) {
                this.ambientParticles.forEach(particle => {
                    particle.userData.velocity.add(particle.userData.drift);
                    particle.position.add(particle.userData.velocity);
                    particle.userData.velocity.multiplyScalar(0.98);
                    
                    if (particle.position.x > 30) particle.position.x = -30;
                    if (particle.position.x < -30) particle.position.x = 30;
                    if (particle.position.z > 30) particle.position.z = -30;
                    if (particle.position.z < -30) particle.position.z = 30;
                    if (particle.position.y > 20) particle.position.y = 0;
                    if (particle.position.y < 0) particle.position.y = 20;
                    
                    const pulse = Math.sin(this.time * 2 + particle.position.x * 0.1) * 0.1;
                    particle.material.opacity = (0.1 + Math.random() * 0.2) * (1 + pulse);
                });
            }

            update(deltaTime = 0.016) {
                this.time += deltaTime;
                
                this.beings.forEach(being => {
                    this.updateBeing(being, deltaTime);
                });
                
                this.updateAmbientParticles(deltaTime);
            }

            applyMouseInfluence(mouseX, mouseY, strength = 1.0) {
                const mouseInfluence = new THREE.Vector3(mouseX * 2, mouseY * 2, 0);
                
                this.beings.forEach(being => {
                    being.particles.forEach(particle => {
                        const distance = particle.position.distanceTo(
                            new THREE.Vector3(mouseInfluence.x * 10, mouseInfluence.y * 10 + 5, 0)
                        );
                        if (distance < 10) {
                            const force = mouseInfluence.clone()
                                .sub(particle.position)
                                .normalize()
                                .multiplyScalar(0.01 * strength);
                            particle.userData.velocity.add(force);
                        }
                    });
                });
            }

            dispose() {
                this.beings.forEach(being => {
                    being.particles.forEach(particle => {
                        particle.geometry.dispose();
                        particle.material.dispose();
                        this.scene.remove(particle);
                    });
                    if (being.userData.originalMesh) {
                        being.userData.originalMesh.visible = true;
                    }
                });
                
                this.ambientParticles.forEach(particle => {
                    particle.geometry.dispose();
                    particle.material.dispose();
                    this.scene.remove(particle);
                });
                
                this.beings = [];
                this.ambientParticles = [];
            }
        }

        // Main Application
        let scene, camera, renderer;
        let particleSystem;
        let time = 0;
        let mouse = new THREE.Vector2();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f8f6); // Toned white default

            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(0, 10, 40);
            camera.lookAt(0, 5, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            particleSystem = new ParticleBeingSystem(scene);
            
            createNewBeing();
            particleSystem.createAmbientParticles(100);
            setupControls();
            
            animate();
        }

        function setupControls() {
            const particleCountSlider = document.getElementById('particleCount');
            const particleCountDisplay = document.getElementById('particleCountDisplay');
            particleCountSlider.addEventListener('input', (e) => {
                particleCountDisplay.textContent = e.target.value;
            });
            
            const speedSlider = document.getElementById('speedMultiplier');
            const speedDisplay = document.getElementById('speedDisplay');
            speedSlider.addEventListener('input', (e) => {
                speedDisplay.textContent = e.target.value;
                if (particleSystem) {
                    particleSystem.options.speedMultiplier = parseFloat(e.target.value);
                }
            });
            
            // Color control listeners
            const figureColorSelect = document.getElementById('figureColor');
            const backgroundColorSelect = document.getElementById('backgroundColor');
            
            figureColorSelect.addEventListener('change', updateColors);
            backgroundColorSelect.addEventListener('change', updateColors);
            
            // Initialize with default colors
            updateColors();
        }

        function getColorOptions(theme) {
            const themes = {
                'light-charcoal': { h: 0, s: 0, lMin: 0.25, lMax: 0.35 },
                'white': { h: 0, s: 0, lMin: 0.85, lMax: 0.95 },
                'warm-gray': { h: 0.08, s: 0.1, lMin: 0.4, lMax: 0.6 },
                'cool-gray': { h: 0.6, s: 0.1, lMin: 0.4, lMax: 0.6 },
                'warm': { h: 0.05, s: 0.7, lMin: 0.4, lMax: 0.7 },
                'cool': { h: 0.6, s: 0.5, lMin: 0.3, lMax: 0.7 },
                'rainbow': { h: Math.random(), s: 0.7, lMin: 0.4, lMax: 0.8 }
            };
            return themes[theme] || themes['light-charcoal'];
        }
        
        function getBackgroundColor(theme) {
            const backgrounds = {
                'toned-white': 0xf8f8f6,
                'pure-white': 0xffffff,
                'light-gray': 0xe0e0e0,
                'dark-blue': 0x1a1a2e,
                'charcoal': 0x2d2d2d,
                'black': 0x000000,
                'gradient-purple': 0x667eea,
                'gradient-blue': 0x4facfe
            };
            return backgrounds[theme] || backgrounds['toned-white'];
        }
        
        function updateColors() {
            const backgroundColor = document.getElementById('backgroundColor').value;
            const figureColor = document.getElementById('figureColor').value;
            
            // Update scene background
            scene.background = new THREE.Color(getBackgroundColor(backgroundColor));
            
            // Update body background for gradient themes
            if (backgroundColor === 'gradient-purple') {
                document.body.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
            } else if (backgroundColor === 'gradient-blue') {
                document.body.style.background = 'linear-gradient(135deg, #4facfe, #00f2fe)';
            } else {
                document.body.style.background = `#${getBackgroundColor(backgroundColor).toString(16).padStart(6, '0')}`;
            }
            
            // Update existing particle colors
            const colorOptions = getColorOptions(figureColor);
            particleSystem.beings.forEach(being => {
                being.particles.forEach((particle, i) => {
                    if (figureColor === 'rainbow') {
                        particle.material.color.setHSL(
                            (i / being.particles.length) % 1,
                            0.7,
                            0.6
                        );
                    } else {
                        particle.material.color.setHSL(
                            colorOptions.h,
                            colorOptions.s,
                            colorOptions.lMin + Math.random() * (colorOptions.lMax - colorOptions.lMin)
                        );
                    }
                });
            });
            
            // Update control panel colors based on background
            const controls = document.querySelector('.controls');
            const info = document.querySelector('.info');
            const buttons = document.querySelectorAll('button');
            const selects = document.querySelectorAll('select');
            const spans = document.querySelectorAll('span');
            
            if (backgroundColor === 'toned-white' || backgroundColor === 'pure-white' || backgroundColor === 'light-gray') {
                // Dark controls for light backgrounds
                controls.style.background = 'rgba(0, 0, 0, 0.1)';
                controls.style.color = '#333';
                controls.style.borderColor = 'rgba(0, 0, 0, 0.1)';
                info.style.color = 'rgba(0, 0, 0, 0.6)';
                
                buttons.forEach(btn => {
                    btn.style.background = 'rgba(0, 0, 0, 0.1)';
                    btn.style.color = '#333';
                    btn.style.borderColor = 'rgba(0, 0, 0, 0.2)';
                });
                
                selects.forEach(select => {
                    select.style.background = 'rgba(255, 255, 255, 0.8)';
                    select.style.color = '#333';
                    select.style.borderColor = 'rgba(0, 0, 0, 0.2)';
                });
                
                spans.forEach(span => {
                    span.style.color = '#555';
                });
            } else {
                // Light controls for dark backgrounds
                controls.style.background = 'rgba(255, 255, 255, 0.1)';
                controls.style.color = 'white';
                controls.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                info.style.color = 'rgba(255, 255, 255, 0.8)';
                
                buttons.forEach(btn => {
                    btn.style.background = 'rgba(255, 255, 255, 0.2)';
                    btn.style.color = 'white';
                    btn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                });
                
                selects.forEach(select => {
                    select.style.background = 'rgba(255, 255, 255, 0.2)';
                    select.style.color = 'white';
                    select.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                });
                
                spans.forEach(span => {
                    span.style.color = '#ffd700';
                });
            }
        }

        function createNewBeing() {
            const bodyType = document.getElementById('bodyType').value;
            const particleCount = parseInt(document.getElementById('particleCount').value);
            const speedMultiplier = parseFloat(document.getElementById('speedMultiplier').value);
            const figureColor = document.getElementById('figureColor').value;
            
            const position = {
                x: (Math.random() - 0.5) * 20,
                y: 0,
                z: (Math.random() - 0.5) * 15
            };
            
            const colorOptions = getColorOptions(figureColor);
            
            const being = particleSystem.convertToParticleBeing(
                null,
                position,
                {
                    particleCount: particleCount,
                    speedMultiplier: speedMultiplier,
                    colorRange: colorOptions,
                    states: ['forming', 'stable', 'dancing', 'dissolving', 'scattered'],
                    stateTimings: {
                        forming: 3,
                        stable: 4,
                        dancing: 3,
                        dissolving: 2,
                        scattered: 2
                    }
                }
            );
            
            // Generate silhouette with correct body type
            being.particles.forEach(particle => {
                scene.remove(particle);
                particle.geometry.dispose();
                particle.material.dispose();
            });
            being.particles = [];
            
            const points = particleSystem.generateHumanSilhouettePoints(particleCount, bodyType);
            points.forEach((point, i) => {
                const particle = particleSystem.createParticle(
                    point,
                    position,
                    {
                        ...particleSystem.options,
                        particleCount: particleCount,
                        speedMultiplier: speedMultiplier,
                        colorRange: colorOptions
                    }
                );
                particle.userData.beingIndex = particleSystem.beings.length - 1;
                particle.userData.particleIndex = i;
                
                scene.add(particle);
                being.particles.push(particle);
            });
            
            if (figureColor === 'rainbow') {
                being.particles.forEach((particle, i) => {
                    particle.material.color.setHSL(
                        (i / particleCount) % 1,
                        0.7,
                        0.6
                    );
                });
            }
        }

        function clearAll() {
            particleSystem.beings.forEach(being => {
                being.particles.forEach(particle => {
                    particle.geometry.dispose();
                    particle.material.dispose();
                    scene.remove(particle);
                });
            });
            particleSystem.beings = [];
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            if (particleSystem) {
                particleSystem.update(0.016);
                particleSystem.applyMouseInfluence(mouse.x, mouse.y, 0.5);
            }

            const radius = 35 + Math.sin(time * 0.05) * 10;
            camera.position.x = Math.sin(time * 0.03) * radius;
            camera.position.z = Math.cos(time * 0.03) * radius;
            camera.position.y = 10 + Math.sin(time * 0.02) * 5;
            camera.lookAt(0, 5, 0);

            renderer.render(scene, camera);
        }

        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>