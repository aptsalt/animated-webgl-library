<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life Journey - Athlete Competing</title>
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: linear-gradient(135deg, #ff4500, #ff6347, #ffd700, #ff4500);
            animation: energyPulse 2s infinite;
        }
        canvas { display: block; }
        .title { 
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); 
            color: #fff; font-family: 'Impact', sans-serif; font-size: 42px; 
            letter-spacing: 4px; text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            text-transform: uppercase;
        }
        .sport-mode {
            position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
            color: #ffff00; font-family: 'Arial Black', sans-serif; font-size: 20px; 
            font-weight: bold; letter-spacing: 3px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        @keyframes energyPulse {
            0%, 100% { filter: brightness(1) saturate(1); }
            50% { filter: brightness(1.2) saturate(1.3); }
        }
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(26, 26, 26, 0.4);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="title">ATHLETE COMPETING</div>
    <div class="sport-mode" id="sportMode">SPRINTING</div>
    <div class="instruction">Click to interact with the scene</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="../particle-being-library.js"></script>
    <script>
        let scene, camera, renderer, particleSystem;
        let time = 0;
        let currentSport = 0;
        let sportTimer = 0;
        let energyTrails = [];
        let competitors = [];
        let arena = [];
        
        const sports = [
            'SPRINTING', 'HIGH JUMP', 'SWIMMING', 'BOXING',
            'GYMNASTICS', 'WEIGHTLIFTING', 'MARATHON'
        ];

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create powerful athlete particle system
            particleSystem = new ParticleBeingSystem(scene, {
                particleCount: 350, // Large, powerful athlete
                particleSize: 0.12, // Bigger particles for strength
                speedMultiplier: 4.0, // Extremely fast
                colorRange: { h: 0.05, s: 0.9, lMin: 0.4, lMax: 0.8 }
            });

            createAthlete();
            createCompetitors();
            createArena();
            animate();
        }

        function createAthlete() {
            const athlete = particleSystem.convertToParticleBeing(
                null,
                { x: 0, y: 0, z: 0 },
                {
                    particleCount: 400, // Large muscular build
                    states: ['preparing', 'competing', 'pushing-limits', 'victory'],
                    stateTimings: { preparing: 3, competing: 4, 'pushing-limits': 3, victory: 2 },
                    attractionForces: { preparing: 0.04, competing: 0.02, 'pushing-limits': 0.015, victory: 0.03 }
                }
            );

            // 7 completely different sports with unique physics
            const originalUpdate = particleSystem.updateBeing.bind(particleSystem);
            particleSystem.updateBeing = function(being, deltaTime) {
                originalUpdate(being, deltaTime);
                
                sportTimer += deltaTime;
                if (sportTimer > 5) {
                    currentSport = (currentSport + 1) % sports.length;
                    sportTimer = 0;
                    document.getElementById('sportMode').textContent = sports[currentSport];
                }
                
                switch(currentSport) {
                    case 0: // SPRINTING - Extreme speed, horizontal stretch
                        being.particles.forEach((particle, i) => {
                            // Massive horizontal stretch for speed
                            particle.scale.x = 3.0;
                            particle.scale.y = 0.7;
                            particle.scale.z = 0.5;
                            
                            // Extreme forward velocity
                            particle.userData.velocity.x += 0.08;
                            particle.userData.velocity.y += Math.sin(time * 30 + i) * 0.01; // Bouncing
                            
                            // Speed blur
                            particle.material.opacity = 0.6 + Math.sin(time * 50) * 0.4;
                            
                            // Create speed trails
                            if (Math.random() < 0.3) {
                                createSpeedTrail(particle.position, new THREE.Vector3(-0.5, 0, 0));
                            }
                        });
                        
                        // Racing across screen
                        being.userData.basePosition.x += 0.8;
                        if (being.userData.basePosition.x > 50) {
                            being.userData.basePosition.x = -50;
                        }
                        
                        // Fast tracking camera
                        camera.position.x = being.userData.basePosition.x - 10;
                        camera.position.y = 5;
                        camera.position.z = 20;
                        camera.lookAt(being.userData.basePosition);
                        break;
                        
                    case 1: // HIGH JUMP - Vertical explosion, body arching
                        being.particles.forEach((particle, i) => {
                            particle.scale.setScalar(1.2);
                            
                            const jumpPhase = Math.sin(time * 4);
                            
                            if (jumpPhase > 0) { // Jumping phase
                                // Vertical stretch and arch
                                particle.scale.y = 2.0;
                                particle.scale.x = 0.8;
                                
                                // Body arching over bar
                                if (i > 80 && i < 200) { // Torso
                                    particle.userData.targetPosition.y += jumpPhase * 8;
                                    particle.userData.targetPosition.z += Math.sin(jumpPhase * Math.PI) * 3;
                                }
                                
                                // Legs trailing
                                if (i > 250) {
                                    particle.userData.targetPosition.y += jumpPhase * 6;
                                }
                            } else { // Landing/preparing
                                particle.scale.setScalar(1.0);
                                // Crouching preparation
                                particle.userData.targetPosition.y *= 0.7;
                            }
                        });
                        
                        being.userData.basePosition.y = Math.max(0, Math.sin(time * 4) * 12);
                        
                        // Side view camera for jump
                        camera.position.set(25, 8, 0);
                        camera.lookAt(0, 5, 0);
                        break;
                        
                    case 2: // SWIMMING - Fluid motion, streamlined body
                        being.particles.forEach((particle, i) => {
                            // Streamlined body shape
                            particle.scale.x = 2.5;
                            particle.scale.y = 0.6;
                            particle.scale.z = 0.8;
                            
                            // Fluid swimming motion
                            const swimPhase = time * 8 + i * 0.1;
                            particle.userData.velocity.x += Math.sin(swimPhase) * 0.02;
                            particle.userData.velocity.y += Math.cos(swimPhase * 1.5) * 0.005;
                            
                            // Stroke motion
                            if (i > 100 && i < 150) { // Arms
                                particle.userData.targetPosition.x += Math.sin(time * 12) * 2;
                                particle.userData.targetPosition.y += Math.cos(time * 12) * 1;
                            }
                            
                            // Water effect color
                            particle.material.color.setHSL(0.55, 0.8, 0.6 + Math.sin(swimPhase) * 0.2);
                            
                            // Splash particles
                            if (Math.random() < 0.1) {
                                createWaterSplash(particle.position);
                            }
                        });
                        
                        // Swimming across pool
                        being.userData.basePosition.x += 0.3;
                        being.userData.basePosition.y = Math.sin(time * 6) * 0.5; // Bobbing
                        
                        // Pool-side camera
                        camera.position.set(0, 15, 25);
                        camera.lookAt(being.userData.basePosition);
                        break;
                        
                    case 3: // BOXING - Rapid punching, defensive stances
                        being.particles.forEach((particle, i) => {
                            particle.scale.setScalar(1.4); // Muscular build
                            
                            // Punching motion
                            const punchPhase = Math.sin(time * 25);
                            if (i > 80 && i < 120) { // Arms
                                if (punchPhase > 0.7) {
                                    // Rapid punch extension
                                    particle.userData.velocity.x += 0.15;
                                    particle.scale.x = 3.0;
                                } else {
                                    // Guard position
                                    particle.userData.targetPosition.x = 0.5;
                                    particle.userData.targetPosition.y += 1;
                                }
                            }
                            
                            // Head movement (dodging)
                            if (i < 50) {
                                particle.userData.velocity.x += Math.sin(time * 15) * 0.02;
                                particle.userData.velocity.y += Math.cos(time * 20) * 0.01;
                            }
                            
                            // Footwork
                            if (i > 300) {
                                particle.userData.velocity.x += Math.sin(time * 12) * 0.01;
                                particle.userData.velocity.z += Math.cos(time * 10) * 0.01;
                            }
                        });
                        
                        // Boxing ring movement
                        being.userData.basePosition.x = Math.sin(time * 3) * 5;
                        being.userData.basePosition.z = Math.cos(time * 2.5) * 3;
                        
                        // Ring-side camera
                        camera.position.set(8, 6, 15);
                        camera.lookAt(being.userData.basePosition);
                        break;
                        
                    case 4: // GYMNASTICS - Graceful spins, flexible poses
                        being.particles.forEach((particle, i) => {
                            particle.scale.setScalar(0.9); // Lean gymnast build
                            
                            // Spinning rotation
                            const spin = time * 10;
                            const rotatedPos = new THREE.Vector3(
                                particle.userData.targetPosition.x * Math.cos(spin) - particle.userData.targetPosition.z * Math.sin(spin),
                                particle.userData.targetPosition.y,
                                particle.userData.targetPosition.x * Math.sin(spin) + particle.userData.targetPosition.z * Math.cos(spin)
                            );
                            
                            particle.position.lerp(rotatedPos.add(being.userData.basePosition), 0.1);
                            
                            // Graceful extensions
                            if (i > 100 && i < 150) { // Arms
                                particle.userData.targetPosition.x *= 1.8;
                                particle.userData.targetPosition.y += Math.sin(spin) * 2;
                            }
                            
                            // Leg splits
                            if (i > 250) {
                                if (i % 2 === 0) {
                                    particle.userData.targetPosition.x += 3;
                                } else {
                                    particle.userData.targetPosition.x -= 3;
                                }
                            }
                        });
                        
                        // Airborne gymnastics
                        being.userData.basePosition.y = 5 + Math.sin(time * 6) * 3;
                        
                        // Artistic camera angles
                        camera.position.set(
                            Math.sin(time * 0.5) * 20,
                            10,
                            Math.cos(time * 0.5) * 20
                        );
                        camera.lookAt(being.userData.basePosition);
                        break;
                        
                    case 5: // WEIGHTLIFTING - Massive size, power poses
                        being.particles.forEach((particle, i) => {
                            // Massive muscular form
                            particle.scale.setScalar(2.0);
                            
                            const liftPhase = Math.sin(time * 3);
                            
                            if (liftPhase > 0) { // Lifting phase
                                // Extreme muscle tension
                                particle.scale.setScalar(2.5);
                                particle.material.color.setHSL(0, 0.9, 0.3); // Deep red strain
                                
                                // Arms lifting overhead
                                if (i > 80 && i < 120) {
                                    particle.userData.targetPosition.y += liftPhase * 6;
                                    particle.userData.targetPosition.x *= 1.5;
                                }
                                
                                // Legs braced
                                if (i > 300) {
                                    particle.userData.targetPosition.x *= 1.3;
                                }
                            } else { // Preparation/rest
                                particle.scale.setScalar(1.8);
                                particle.material.color.setHSL(0.05, 0.8, 0.5);
                            }
                            
                            // Power trembling
                            particle.position.x += (Math.random() - 0.5) * 0.02;
                        });
                        
                        being.userData.basePosition.y = -1;
                        
                        // Power-focused camera
                        camera.position.set(0, 5, 18);
                        camera.lookAt(0, 2, 0);
                        break;
                        
                    case 6: // MARATHON - Endurance rhythm, steady pace
                        being.particles.forEach((particle, i) => {
                            // Lean endurance build
                            particle.scale.setScalar(0.8);
                            
                            // Steady rhythmic motion
                            const rhythm = time * 6;
                            particle.userData.velocity.x += Math.sin(rhythm) * 0.005;
                            particle.userData.velocity.y += Math.abs(Math.sin(rhythm * 2)) * 0.002;
                            
                            // Breathing rhythm
                            if (i < 100) { // Chest
                                particle.position.multiplyScalar(1 + Math.sin(time * 8) * 0.02);
                            }
                            
                            // Steady arm swing
                            if (i > 100 && i < 150) {
                                particle.userData.targetPosition.x += Math.sin(rhythm + Math.PI) * 0.8;
                                particle.userData.targetPosition.z += Math.cos(rhythm) * 0.3;
                            }
                            
                            // Fatigue effect (slight opacity change)
                            particle.material.opacity = 0.9 + Math.sin(time * 0.5) * 0.1;
                        });
                        
                        // Long distance movement
                        being.userData.basePosition.x = (time * 0.5) % 100 - 50;
                        
                        // Following endurance camera
                        camera.position.set(
                            being.userData.basePosition.x + 5,
                            8,
                            25
                        );
                        camera.lookAt(being.userData.basePosition);
                        break;
                }
                
                updateEnergyTrails();
            };

            particleSystem.createAmbientParticles(200);
        }

        function createCompetitors() {
            // Create 2 competitor athletes
            for (let i = 0; i < 2; i++) {
                const competitor = particleSystem.convertToParticleBeing(
                    null,
                    { x: (i + 1) * 15, y: 0, z: 5 },
                    {
                        particleCount: 250,
                        speedMultiplier: 3.5,
                        colorRange: { h: 0.15 + i * 0.3, s: 0.8, lMin: 0.4, lMax: 0.7 }
                    }
                );
                competitors.push(competitor);
            }
        }

        function createArena() {
            // Create arena boundaries
            for (let i = 0; i < 8; i++) {
                const boundary = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 5, 1),
                    new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.3
                    })
                );
                const angle = (i / 8) * Math.PI * 2;
                boundary.position.set(
                    Math.cos(angle) * 25,
                    0,
                    Math.sin(angle) * 25
                );
                scene.add(boundary);
                arena.push(boundary);
            }
        }

        function createSpeedTrail(position, velocity) {
            const trail = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 4, 4),
                new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8
                })
            );
            trail.position.copy(position);
            trail.userData = { velocity: velocity.clone(), life: 0 };
            scene.add(trail);
            energyTrails.push(trail);
        }

        function createWaterSplash(position) {
            const splash = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 6, 6),
                new THREE.MeshBasicMaterial({
                    color: 0x00aaff,
                    transparent: true,
                    opacity: 0.6
                })
            );
            splash.position.copy(position);
            splash.userData = { 
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.1,
                    (Math.random() - 0.5) * 0.1
                ), 
                life: 0 
            };
            scene.add(splash);
            energyTrails.push(splash);
        }

        function updateEnergyTrails() {
            energyTrails = energyTrails.filter(trail => {
                trail.userData.life += 0.016;
                trail.position.add(trail.userData.velocity);
                trail.userData.velocity.multiplyScalar(0.98);
                trail.material.opacity = Math.max(0, 0.8 - trail.userData.life * 0.5);
                
                if (trail.material.opacity <= 0) {
                    scene.remove(trail);
                    return false;
                }
                return true;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            particleSystem.update(0.016);
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>