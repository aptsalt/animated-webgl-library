<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life Journey - Child Playing</title>
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at 30% 70%, #87ceeb, #98fb98, #ffb6c1, #dda0dd);
            animation: colorShift 10s infinite;
        }
        canvas { display: block; }
        .title { 
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); 
            color: #ff69b4; font-family: 'Comic Sans MS', cursive; font-size: 36px; 
            letter-spacing: 3px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: rainbow 3s infinite;
        }
        .play-mode {
            position: absolute; top: 65px; left: 50%; transform: translateX(-50%);
            color: #4169e1; font-family: sans-serif; font-size: 18px; 
            font-weight: bold; letter-spacing: 2px;
        }
        @keyframes colorShift {
            0% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(180deg); }
            100% { filter: hue-rotate(360deg); }
        }
        @keyframes rainbow {
            0% { color: #ff69b4; }
            14% { color: #ff6347; }
            28% { color: #ffd700; }
            42% { color: #32cd32; }
            57% { color: #00bfff; }
            71% { color: #9932cc; }
            85% { color: #ff1493; }
            100% { color: #ff69b4; }
        }
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(26, 26, 26, 0.4);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="title">CHILD PLAYING</div>
    <div class="play-mode" id="playMode">HIDE AND SEEK</div>
    <div class="instruction">Click to interact with the scene</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="../particle-being-library.js"></script>
    <script>
        let scene, camera, renderer, particleSystem;
        let time = 0;
        let currentMode = 0;
        let modeTimer = 0;
        let playmates = [];
        let playground = [];
        let imagination = [];
        
        const playModes = [
            'HIDE AND SEEK', 'TAG RACING', 'IMAGINATION PLAY', 'BUILDING BLOCKS',
            'FLYING LIKE SUPERMAN', 'DANCING PARTY', 'ADVENTURE QUEST'
        ];

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create playful child particle system
            particleSystem = new ParticleBeingSystem(scene, {
                particleCount: 220, // Medium size energetic child
                particleSize: 0.07,
                speedMultiplier: 3.0, // Very energetic
                colorRange: { h: 0.55, s: 0.8, lMin: 0.5, lMax: 0.8 }
            });

            createChildren();
            createPlayground();
            animate();
        }

        function createChildren() {
            // Create 3 children for group play
            for (let i = 0; i < 3; i++) {
                const child = particleSystem.convertToParticleBeing(
                    null,
                    { x: (i - 1) * 8, y: 0, z: 0 },
                    {
                        particleCount: 180 + i * 20, // Different sizes
                        states: ['playing', 'laughing', 'running', 'imagining'],
                        stateTimings: { playing: 3, laughing: 2, running: 2, imagining: 4 },
                        attractionForces: { playing: 0.025, laughing: 0.015, running: 0.01, imagining: 0.03 }
                    }
                );
                
                // Give each child different colored particles
                child.particles.forEach(particle => {
                    particle.material.color.setHSL((i * 0.33 + time) % 1, 0.8, 0.6);
                });
                
                playmates.push(child);
            }

            // 7 completely different play scenarios
            const originalUpdate = particleSystem.updateBeing.bind(particleSystem);
            particleSystem.updateBeing = function(being, deltaTime) {
                originalUpdate(being, deltaTime);
                
                modeTimer += deltaTime;
                if (modeTimer > 6) {
                    currentMode = (currentMode + 1) % playModes.length;
                    modeTimer = 0;
                    document.getElementById('playMode').textContent = playModes[currentMode];
                }
                
                const beingIndex = particleSystem.beings.indexOf(being);
                
                switch(currentMode) {
                    case 0: // HIDE AND SEEK - Small, crouching, invisible phases
                        being.particles.forEach((particle, i) => {
                            // Shrinking to hide
                            const hidePhase = Math.sin(time * 2 + beingIndex * 2);
                            if (hidePhase > 0.5) {
                                particle.scale.setScalar(0.3); // Very small when hiding
                                particle.material.opacity = 0.2; // Nearly invisible
                                particle.userData.targetPosition.y *= 0.3; // Crouching
                            } else {
                                particle.scale.setScalar(1.2); // Bigger when seeking
                                particle.material.opacity = 1.0;
                                // Looking around motion
                                particle.userData.velocity.x += Math.sin(time * 8 + i * 0.1) * 0.002;
                            }
                        });
                        
                        // Hide behind playground objects
                        if (Math.sin(time * 2 + beingIndex * 2) > 0.5) {
                            being.userData.basePosition.x = playground[beingIndex % playground.length]?.position.x || 0;
                            being.userData.basePosition.z = playground[beingIndex % playground.length]?.position.z || 0;
                        }
                        
                        camera.position.set(
                            Math.sin(time * 0.5) * 30,
                            12,
                            Math.cos(time * 0.5) * 30
                        );
                        break;
                        
                    case 1: // TAG RACING - Very fast, stretched particles, motion blur
                        being.particles.forEach((particle, i) => {
                            particle.scale.setScalar(0.9);
                            // High speed running
                            const runDirection = new THREE.Vector3(
                                Math.cos(time * 5 + beingIndex * 2),
                                0,
                                Math.sin(time * 5 + beingIndex * 2)
                            );
                            particle.userData.velocity.add(runDirection.multiplyScalar(0.05));
                            
                            // Motion blur effect
                            particle.material.opacity = 0.7;
                            
                            // Stretched particles for speed effect
                            if (i % 3 === 0) {
                                particle.scale.z = 2.0;
                                particle.scale.x = 0.5;
                            }
                        });
                        
                        // Circular chase pattern
                        const chaseRadius = 15;
                        being.userData.basePosition.x = Math.cos(time * 8 + beingIndex * 2) * chaseRadius;
                        being.userData.basePosition.z = Math.sin(time * 8 + beingIndex * 2) * chaseRadius;
                        
                        // Fast following camera
                        camera.position.set(0, 20, 50);
                        camera.lookAt(0, 0, 0);
                        break;
                        
                    case 2: // IMAGINATION PLAY - Morphing shapes, fantasy elements
                        being.particles.forEach((particle, i) => {
                            // Transform into imaginary creatures
                            const fantasy = Math.sin(time * 3 + beingIndex + i * 0.1);
                            
                            if (beingIndex === 0) { // Dragon
                                particle.scale.setScalar(1.5);
                                particle.material.color.setHSL(0, 0.8, 0.7);
                                particle.userData.targetPosition.y += Math.sin(time * 10 + i) * 0.5;
                                if (i < 50) { // Wings
                                    particle.userData.targetPosition.x += Math.cos(time * 15) * 3;
                                    particle.userData.targetPosition.y += Math.abs(Math.sin(time * 15)) * 2;
                                }
                            } else if (beingIndex === 1) { // Princess
                                particle.scale.setScalar(1.3);
                                particle.material.color.setHSL(0.8, 0.6, 0.8);
                                if (i > 100) { // Dress flowing
                                    particle.userData.targetPosition.y -= 1;
                                    particle.userData.targetPosition.x += Math.sin(time * 8 + i) * 1;
                                }
                            } else { // Superhero
                                particle.scale.setScalar(1.4);
                                particle.material.color.setHSL(0.6, 0.9, 0.6);
                                if (i < 30) { // Cape
                                    particle.userData.targetPosition.z -= 2;
                                    particle.userData.targetPosition.y += Math.sin(time * 12) * 1;
                                }
                            }
                        });
                        
                        // Create imagination sparkles
                        if (Math.random() < 0.1) {
                            createImaginationSparkle(being.userData.basePosition);
                        }
                        
                        camera.position.set(
                            Math.sin(time * 0.3) * 40,
                            25,
                            Math.cos(time * 0.3) * 40
                        );
                        break;
                        
                    case 3: // BUILDING BLOCKS - Geometric shapes, construction motion
                        being.particles.forEach((particle, i) => {
                            // Form geometric building blocks
                            particle.scale.setScalar(0.8);
                            
                            const blockSize = 8;
                            const blockX = Math.floor(particle.userData.targetPosition.x / blockSize) * blockSize;
                            const blockY = Math.floor(particle.userData.targetPosition.y / blockSize) * blockSize;
                            const blockZ = Math.floor(particle.userData.targetPosition.z / blockSize) * blockSize;
                            
                            // Snap to block grid
                            particle.userData.targetPosition.set(blockX, blockY + beingIndex * 2, blockZ);
                            
                            // Building motion - stacking upward
                            if (i % 20 === 0) {
                                particle.userData.velocity.y += 0.01;
                            }
                            
                            // Block colors
                            particle.material.color.setHSL(
                                (Math.floor(i / 20) * 0.2) % 1,
                                0.8,
                                0.6
                            );
                        });
                        
                        being.userData.basePosition.y += Math.sin(time * 4) * 0.1;
                        
                        camera.position.set(25, 15, 25);
                        camera.lookAt(0, 5, 0);
                        break;
                        
                    case 4: // FLYING LIKE SUPERMAN - Aerial motion, stretched form
                        being.particles.forEach((particle, i) => {
                            particle.scale.setScalar(1.1);
                            
                            // Flying pose - arms extended
                            if (i > 80 && i < 120) { // Arms
                                particle.userData.targetPosition.x *= 2;
                                particle.userData.targetPosition.y += 1;
                            }
                            
                            // Cape fluttering
                            if (i > 140) {
                                particle.userData.targetPosition.z -= 2 + Math.sin(time * 20 + i) * 1;
                                particle.userData.targetPosition.y += Math.cos(time * 15 + i) * 0.5;
                            }
                            
                            // Speed lines
                            particle.material.opacity = 0.8 + Math.sin(time * 30 + i) * 0.2;
                        });
                        
                        // Flying through space
                        being.userData.basePosition.y = 8 + Math.sin(time * 4 + beingIndex) * 6;
                        being.userData.basePosition.x = Math.cos(time * 2 + beingIndex * 2) * 20;
                        being.userData.basePosition.z = Math.sin(time * 1.5 + beingIndex * 2) * 15;
                        
                        // Dynamic flying camera
                        camera.position.set(
                            being.userData.basePosition.x - 15,
                            being.userData.basePosition.y + 5,
                            being.userData.basePosition.z + 20
                        );
                        camera.lookAt(being.userData.basePosition);
                        break;
                        
                    case 5: // DANCING PARTY - Rhythmic motion, size pulsing
                        being.particles.forEach((particle, i) => {
                            // Pulsing to the beat
                            const beat = Math.sin(time * 12) * 0.3 + 1;
                            particle.scale.setScalar(beat);
                            
                            // Dance moves
                            particle.userData.velocity.x += Math.sin(time * 16 + i * 0.1) * 0.003;
                            particle.userData.velocity.y += Math.abs(Math.sin(time * 20)) * 0.002;
                            particle.userData.velocity.z += Math.cos(time * 14 + i * 0.1) * 0.003;
                            
                            // Disco colors
                            particle.material.color.setHSL(
                                (time * 2 + i * 0.01) % 1,
                                0.9,
                                0.7
                            );
                            
                            // Spinning motion
                            if (i % 10 === 0) {
                                const spin = time * 10;
                                particle.userData.targetPosition.x = Math.cos(spin + i) * 2;
                                particle.userData.targetPosition.z = Math.sin(spin + i) * 2;
                            }
                        });
                        
                        // Group dance formation
                        being.userData.basePosition.x = Math.cos(time * 6 + beingIndex * 2) * 8;
                        being.userData.basePosition.z = Math.sin(time * 6 + beingIndex * 2) * 8;
                        being.userData.basePosition.y = Math.abs(Math.sin(time * 8)) * 3;
                        
                        camera.position.set(0, 25, 30);
                        break;
                        
                    case 6: // ADVENTURE QUEST - Exploration, climbing, jumping
                        being.particles.forEach((particle, i) => {
                            particle.scale.setScalar(1.0);
                            
                            // Adventure gear particles
                            if (i < 20) { // Backpack
                                particle.userData.targetPosition.z -= 1.5;
                                particle.scale.setScalar(1.5);
                                particle.material.color.setHSL(0.1, 0.8, 0.5);
                            }
                            
                            // Climbing motion
                            const climbPhase = Math.sin(time * 6 + beingIndex);
                            if (climbPhase > 0.5) {
                                particle.userData.velocity.y += 0.02;
                                // Reaching motion
                                if (i > 100 && i < 130) {
                                    particle.userData.targetPosition.y += 2;
                                    particle.userData.targetPosition.x += Math.sin(time * 10) * 1;
                                }
                            } else {
                                // Jumping motion
                                if (Math.sin(time * 15) > 0.8) {
                                    particle.userData.velocity.y += 0.05;
                                }
                            }
                        });
                        
                        // Adventure terrain navigation
                        being.userData.basePosition.x = Math.sin(time * 2 + beingIndex) * 15;
                        being.userData.basePosition.y = Math.abs(Math.sin(time * 4 + beingIndex)) * 8;
                        being.userData.basePosition.z = Math.cos(time * 1.5 + beingIndex) * 12;
                        
                        // Adventure following camera
                        camera.position.set(
                            being.userData.basePosition.x + 20,
                            being.userData.basePosition.y + 10,
                            being.userData.basePosition.z + 25
                        );
                        camera.lookAt(being.userData.basePosition);
                        break;
                }
                
                updateImagination();
            };

            particleSystem.createAmbientParticles(150);
        }

        function createPlayground() {
            // Create playground equipment
            const equipment = ['slide', 'swing', 'seesaw', 'jungle_gym'];
            
            for (let i = 0; i < 4; i++) {
                const item = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 3, 1),
                    new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(i * 0.25, 0.7, 0.6),
                        transparent: true,
                        opacity: 0.6
                    })
                );
                item.position.set(
                    (i - 1.5) * 10,
                    0,
                    (i % 2) * 8 - 4
                );
                scene.add(item);
                playground.push(item);
            }
        }

        function createImaginationSparkle(position) {
            const sparkle = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 8),
                new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.8, 0.8),
                    transparent: true,
                    opacity: 1
                })
            );
            sparkle.position.copy(position);
            sparkle.position.add(new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                Math.random() * 5,
                (Math.random() - 0.5) * 5
            ));
            sparkle.userData = { life: 0, speed: 0.02 + Math.random() * 0.02 };
            scene.add(sparkle);
            imagination.push(sparkle);
        }

        function updateImagination() {
            imagination = imagination.filter(sparkle => {
                sparkle.userData.life += sparkle.userData.speed;
                sparkle.position.y += sparkle.userData.speed * 2;
                sparkle.scale.setScalar(1 + sparkle.userData.life);
                sparkle.material.opacity = Math.max(0, 1 - sparkle.userData.life);
                
                if (sparkle.material.opacity <= 0) {
                    scene.remove(sparkle);
                    return false;
                }
                return true;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            particleSystem.update(0.016);
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>